{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"bruno-memory","text":""},{"location":"#overview","title":"Overview","text":"<p>bruno-memory is a high-performance, multi-backend memory system providing persistent storage and intelligent retrieval for AI conversations and context management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd0c Multiple Backends: SQLite, PostgreSQL, Redis, ChromaDB, Qdrant</li> <li>\ud83d\ude80 High Performance: Connection pooling, caching, batch operations</li> <li>\ud83d\udd0d Semantic Search: Vector embeddings with ChromaDB/Qdrant</li> <li>\ud83d\udcbe Flexible Storage: From lightweight SQLite to enterprise PostgreSQL</li> <li>\ud83d\udd04 Smart Context: Intelligent conversation context building</li> <li>\ud83d\udcca Analytics: Built-in analytics and performance tracking</li> <li>\ud83d\udee1\ufe0f Type Safe: Full type hints and Pydantic validation</li> <li>\ud83d\udd27 Extensible: Plugin architecture for custom backends</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import asyncio\nfrom bruno_memory import create_backend\nfrom bruno_core.models import Message, MessageRole, MessageType\n\nasync def main():\n    # Create a SQLite backend\n    backend = create_backend(\"sqlite\", database_path=\"memory.db\")\n    await backend.connect()\n\n    # Store a message\n    message = Message(\n        content=\"Hello, how can I help you today?\",\n        role=MessageRole.ASSISTANT,\n        message_type=MessageType.TEXT\n    )\n    await backend.store_message(message)\n\n    # Retrieve conversation history\n    messages = await backend.retrieve_messages(limit=10)\n    for msg in messages:\n        print(f\"{msg.role}: {msg.content}\")\n\n    await backend.disconnect()\n\nasyncio.run(main())\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install bruno-memory\n</code></pre>"},{"location":"#optional-dependencies","title":"Optional Dependencies","text":"<pre><code># PostgreSQL support\npip install bruno-memory[postgresql]\n\n# Redis support\npip install bruno-memory[redis]\n\n# Vector search with ChromaDB\npip install bruno-memory[chromadb]\n\n# Vector search with Qdrant\npip install bruno-memory[qdrant]\n\n# All backends\npip install bruno-memory[all]\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph TB\n    A[Application] --&gt; B[Factory]\n    B --&gt; C[Backend Interface]\n    C --&gt; D[SQLite Backend]\n    C --&gt; E[PostgreSQL Backend]\n    C --&gt; F[Redis Backend]\n    C --&gt; G[Vector Backends]\n    G --&gt; H[ChromaDB]\n    G --&gt; I[Qdrant]\n\n    J[Managers] --&gt; C\n    J --&gt; K[Conversation Manager]\n    J --&gt; L[Context Builder]\n    J --&gt; M[Memory Retriever]\n\n    N[Utilities] --&gt; O[Cache Layer]\n    N --&gt; P[Backup &amp; Export]\n    N --&gt; Q[Analytics]</code></pre>"},{"location":"#backend-comparison","title":"Backend Comparison","text":"Feature SQLite PostgreSQL Redis ChromaDB Qdrant Setup \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 Performance \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Scalability \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Vector Search \u274c \u274c \u274c \u2705 \u2705 Full-Text Search \u2705 \u2705 \u2705 \u274c \u274c Use Case Dev/Small Enterprise Cache/Fast RAG/Semantic RAG/Scale"},{"location":"#why-bruno-memory","title":"Why bruno-memory?","text":""},{"location":"#purpose-built-for-ai","title":"\ud83c\udfaf Purpose-Built for AI","text":"<p>Unlike generic databases, bruno-memory is specifically designed for AI conversation management with built-in:</p> <ul> <li>Conversation threading and context</li> <li>Semantic similarity search</li> <li>Memory compression and summarization</li> <li>Context window management</li> </ul>"},{"location":"#backend-flexibility","title":"\ud83d\udd0c Backend Flexibility","text":"<p>Start with SQLite for development, scale to PostgreSQL for production, add Redis for caching, and integrate vector databases for RAG\u2014all without changing your application code.</p>"},{"location":"#batteries-included","title":"\ud83d\udce6 Batteries Included","text":"<ul> <li>Caching: Multi-level caching (in-memory + Redis)</li> <li>Backup: Export to JSON, CSV, Excel</li> <li>Analytics: Conversation patterns, usage metrics</li> <li>Migrations: Automated schema management with Alembic</li> </ul>"},{"location":"#production-ready","title":"\ud83d\ude80 Production Ready","text":"<ul> <li>Comprehensive test coverage (&gt;90%)</li> <li>Connection pooling and retry logic</li> <li>Environment-based configuration</li> <li>Fallback chain support</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get up and running in 5 minutes</li> <li>Backend Selection - Choose the right backend for your needs</li> <li>API Reference - Complete API documentation</li> <li>Examples - Real-world usage patterns</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! See Contributing Guide for details.</p>"},{"location":"TESTING/","title":"Testing Guide for bruno-memory","text":""},{"location":"TESTING/#overview","title":"Overview","text":"<p>Bruno-memory has a comprehensive testing infrastructure that supports multiple backends with Docker-based testing environments.</p>"},{"location":"TESTING/#quick-start","title":"Quick Start","text":"<pre><code># Run all tests with Docker\nmake test-docker\n\n# Test specific backend\nmake test-postgresql\n</code></pre>"},{"location":"TESTING/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/                  # Unit tests (no external dependencies)\n\u2502   \u251c\u2500\u2500 test_factory.py\n\u2502   \u251c\u2500\u2500 test_sqlite_backend.py\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 integration/           # Integration tests (require services)\n\u2502   \u251c\u2500\u2500 test_postgresql_integration.py\n\u2502   \u251c\u2500\u2500 test_redis_integration.py\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 conftest.py           # Shared fixtures\n</code></pre>"},{"location":"TESTING/#test-markers","title":"Test Markers","text":"<p>Tests are organized using pytest markers for selective execution:</p>"},{"location":"TESTING/#available-markers","title":"Available Markers","text":"<ul> <li><code>postgresql</code> - Tests requiring PostgreSQL</li> <li><code>redis</code> - Tests requiring Redis</li> <li><code>chromadb</code> - Tests requiring ChromaDB</li> <li><code>qdrant</code> - Tests requiring Qdrant</li> <li><code>vector</code> - Tests requiring any vector database</li> <li><code>requires_docker</code> - Tests requiring Docker services</li> <li><code>slow</code> - Long-running tests</li> <li><code>benchmark</code> - Performance benchmarks</li> </ul>"},{"location":"TESTING/#usage-examples","title":"Usage Examples","text":"<pre><code># Run only PostgreSQL tests\npytest -m postgresql\n\n# Run all vector database tests\npytest -m vector\n\n# Run multiple markers\npytest -m \"postgresql or redis\"\n\n# Exclude specific tests\npytest -m \"not slow\"\n\n# Run integration tests\npytest -m requires_docker\n</code></pre>"},{"location":"TESTING/#docker-testing","title":"Docker Testing","text":""},{"location":"TESTING/#why-docker-testing","title":"Why Docker Testing?","text":"<ul> <li>Consistent environments: Everyone tests against the same service versions</li> <li>Isolated testing: No conflicts with local services</li> <li>Complete coverage: Test all backends without manual setup</li> <li>CI/CD ready: Same environment locally and in CI</li> </ul>"},{"location":"TESTING/#docker-profiles","title":"Docker Profiles","text":""},{"location":"TESTING/#1-minimal-profile","title":"1. Minimal Profile","text":"<p>Fastest startup with essential services only.</p> <p>Services: PostgreSQL, Redis</p> <pre><code># PowerShell\n.\\scripts\\setup-test-env.ps1 -Profile minimal\n\n# Bash\nbash scripts/setup-test-env.sh --profile minimal\n\n# Makefile\nmake test-docker-minimal\n</code></pre> <p>Use cases: - Quick development iterations - Testing core functionality - CI for non-vector features</p>"},{"location":"TESTING/#2-full-profile-default","title":"2. Full Profile (Default)","text":"<p>Complete testing environment with all backends.</p> <p>Services: PostgreSQL, Redis, ChromaDB, Qdrant</p> <pre><code># PowerShell\n.\\scripts\\setup-test-env.ps1 -Profile full\n\n# Bash\nbash scripts/setup-test-env.sh --profile full\n\n# Makefile\nmake test-docker\n</code></pre> <p>Use cases: - Comprehensive testing - Vector database development - Pre-release validation</p>"},{"location":"TESTING/#3-ci-profile","title":"3. CI Profile","text":"<p>Optimized for CI/CD pipelines.</p> <p>Services: All services with tmpfs for speed</p> <pre><code># PowerShell\n.\\scripts\\setup-test-env.ps1 -Profile ci\n\n# Bash\nbash scripts/setup-test-env.sh --profile ci\n</code></pre> <p>Features: - Uses tmpfs for faster I/O - No persistent volumes - Optimized health checks</p>"},{"location":"TESTING/#service-management","title":"Service Management","text":""},{"location":"TESTING/#starting-services","title":"Starting Services","text":"<pre><code># Using Makefile\nmake docker-up\n\n# Using scripts (with options)\n.\\scripts\\setup-test-env.ps1 -Profile full -Pull -Build\nbash scripts/setup-test-env.sh --profile full --pull --build\n\n# Options:\n#   -Pull / --pull   : Pull latest images\n#   -Build / --build : Rebuild custom images\n#   -Clean / --clean : Remove existing containers first\n</code></pre>"},{"location":"TESTING/#checking-service-status","title":"Checking Service Status","text":"<pre><code># Quick status\nmake docker-status\n\n# Detailed status\ndocker-compose ps\n\n# Check individual service\ndocker logs bruno-memory-postgres\n</code></pre>"},{"location":"TESTING/#stopping-services","title":"Stopping Services","text":"<pre><code># Stop services (preserve data)\nmake docker-down\n\n# Stop and remove data\nmake docker-down-volumes\n\n# Complete cleanup\nmake docker-teardown\n</code></pre>"},{"location":"TESTING/#running-tests-with-docker","title":"Running Tests with Docker","text":""},{"location":"TESTING/#automated-test-runs","title":"Automated Test Runs","text":"<p>The test runner handles the complete lifecycle:</p> <pre><code># PowerShell\n.\\scripts\\run-tests-docker.ps1 `\n    -Profile full `\n    -Verbose `\n    -NoCoverage\n\n# Bash\nbash scripts/run-tests-docker.sh \\\n    --profile full \\\n    --verbose \\\n    --no-coverage\n</code></pre> <p>Options: - <code>-Profile</code> / <code>--profile</code>: Environment profile (minimal/full/ci) - <code>-Markers</code> / <code>--markers</code>: Pytest markers to run - <code>-TestPath</code> / <code>--test-path</code>: Specific test path - <code>-Verbose</code> / <code>--verbose</code>: Verbose output - <code>-NoCoverage</code> / <code>--no-coverage</code>: Skip coverage - <code>-KeepEnv</code> / <code>--keep-env</code>: Keep services running after tests - <code>-SetupOnly</code> / <code>--setup-only</code>: Only setup, don't run tests</p>"},{"location":"TESTING/#manual-test-runs","title":"Manual Test Runs","text":"<p>For iterative development, start services once and run tests multiple times:</p> <pre><code># 1. Start services\n.\\scripts\\setup-test-env.ps1 -Profile full\n\n# 2. Run tests as needed\npytest tests/unit/test_postgresql_backend.py -v\npytest tests/ -m postgresql\npytest tests/integration/ -v\n\n# 3. Stop services when done\n.\\scripts\\teardown-test-env.ps1\n</code></pre>"},{"location":"TESTING/#backend-specific-testing","title":"Backend-Specific Testing","text":"<pre><code># Test single backend\nmake test-postgresql\nmake test-redis\nmake test-chromadb\nmake test-qdrant\n\n# Test all vector backends\nmake test-vector\n\n# Using markers directly\npytest -m postgresql -v\npytest -m \"chromadb or qdrant\" -v\n</code></pre>"},{"location":"TESTING/#test-fixtures","title":"Test Fixtures","text":"<p>Docker fixtures are available in <code>tests/conftest.py</code>:</p>"},{"location":"TESTING/#available-fixtures","title":"Available Fixtures","text":"<pre><code># Configuration fixture\ndocker_services_config  # Service connection details\n\n# Backend fixtures (auto-cleanup)\npostgresql_backend      # PostgreSQL backend\nredis_backend          # Redis backend\nchromadb_backend       # ChromaDB backend\nqdrant_backend         # Qdrant backend\n\n# Utility fixtures\nskip_if_no_docker      # Skip if Docker not available\n</code></pre>"},{"location":"TESTING/#using-fixtures-in-tests","title":"Using Fixtures in Tests","text":"<pre><code>import pytest\n\n\nasync def test_postgresql_storage(postgresql_backend):\n    \"\"\"Test PostgreSQL backend storage.\"\"\"\n    # Backend is already connected and cleaned\n    message = create_test_message()\n\n    # Store message\n    msg_id = await postgresql_backend.store_message(message)\n\n    # Retrieve message\n    retrieved = await postgresql_backend.get_message(msg_id)\n    assert retrieved.content == message.content\n\n    # Cleanup happens automatically\n\n\nasync def test_redis_caching(redis_backend):\n    \"\"\"Test Redis caching.\"\"\"\n    # Set value\n    await redis_backend.cache_set(\"key\", \"value\")\n\n    # Get value\n    result = await redis_backend.cache_get(\"key\")\n    assert result == \"value\"\n\n\nasync def test_vector_search(chromadb_backend):\n    \"\"\"Test vector similarity search.\"\"\"\n    # Add vectors\n    await chromadb_backend.add_vectors(vectors, metadata)\n\n    # Search\n    results = await chromadb_backend.search(query_vector, limit=5)\n    assert len(results) &lt;= 5\n</code></pre>"},{"location":"TESTING/#fixture-configuration","title":"Fixture Configuration","text":"<p>Fixtures read configuration from environment variables:</p> <pre><code># PostgreSQL\nPOSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nPOSTGRES_DB=bruno_memory\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=postgres\n\n# Redis\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_DB=15\n\n# ChromaDB\nCHROMA_HOST=localhost\nCHROMA_HTTP_PORT=8000\n\n# Qdrant\nQDRANT_HOST=localhost\nQDRANT_HTTP_PORT=6333\n</code></pre>"},{"location":"TESTING/#connection-testing","title":"Connection Testing","text":"<p>Individual connection test scripts verify service functionality:</p> <pre><code># PostgreSQL\n.\\scripts\\test-postgres-connection.ps1\n\n# Redis\n.\\scripts\\test-redis-connection.ps1\n\n# ChromaDB\n.\\scripts\\test-chromadb-connection.ps1\n\n# Qdrant\n.\\scripts\\test-qdrant-connection.ps1\n</code></pre> <p>These scripts: - Check service availability - Verify health endpoints - Test basic operations - Display configuration</p>"},{"location":"TESTING/#writing-tests","title":"Writing Tests","text":""},{"location":"TESTING/#test-structure_1","title":"Test Structure","text":"<pre><code>\"\"\"Test module for feature X.\"\"\"\n\nimport pytest\nfrom bruno_memory import MemoryFactory\n\n\nclass TestFeatureX:\n    \"\"\"Test suite for feature X.\"\"\"\n\n    async def test_basic_functionality(self):\n        \"\"\"Test basic functionality.\"\"\"\n        # Arrange\n        memory = MemoryFactory.create(\"sqlite\")\n\n        # Act\n        result = await memory.some_operation()\n\n        # Assert\n        assert result is not None\n\n    @pytest.mark.postgresql\n    async def test_with_postgresql(self, postgresql_backend):\n        \"\"\"Test with PostgreSQL backend.\"\"\"\n        # Backend is ready to use\n        result = await postgresql_backend.some_operation()\n        assert result is not None\n\n    @pytest.mark.slow\n    async def test_performance(self):\n        \"\"\"Test performance with large dataset.\"\"\"\n        # Long-running test\n        pass\n</code></pre>"},{"location":"TESTING/#test-best-practices","title":"Test Best Practices","text":""},{"location":"TESTING/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code># Good\nasync def test_store_message_returns_valid_id():\n    ...\n\n# Bad\nasync def test_store():\n    ...\n</code></pre>"},{"location":"TESTING/#2-follow-aaa-pattern","title":"2. Follow AAA Pattern","text":"<pre><code>async def test_retrieve_messages():\n    # Arrange\n    memory = MemoryFactory.create(\"sqlite\")\n    message = create_test_message()\n\n    # Act\n    await memory.store_message(message)\n    messages = await memory.retrieve_messages(limit=10)\n\n    # Assert\n    assert len(messages) == 1\n    assert messages[0].content == message.content\n</code></pre>"},{"location":"TESTING/#3-test-one-thing","title":"3. Test One Thing","text":"<pre><code># Good - tests one aspect\nasync def test_store_message_generates_id():\n    memory = MemoryFactory.create(\"sqlite\")\n    msg_id = await memory.store_message(message)\n    assert msg_id is not None\n\nasync def test_store_message_persists_content():\n    memory = MemoryFactory.create(\"sqlite\")\n    await memory.store_message(message)\n    retrieved = await memory.get_message(message.id)\n    assert retrieved.content == message.content\n\n# Bad - tests multiple things\nasync def test_store_message():\n    memory = MemoryFactory.create(\"sqlite\")\n    msg_id = await memory.store_message(message)\n    assert msg_id is not None\n    retrieved = await memory.get_message(msg_id)\n    assert retrieved.content == message.content\n    assert retrieved.timestamp is not None\n    # ... more assertions\n</code></pre>"},{"location":"TESTING/#4-use-fixtures-for-setup","title":"4. Use Fixtures for Setup","text":"<pre><code>@pytest.fixture\nasync def memory_with_messages():\n    \"\"\"Fixture providing memory backend with test messages.\"\"\"\n    memory = MemoryFactory.create(\"sqlite\")\n    messages = [create_test_message() for _ in range(10)]\n    for msg in messages:\n        await memory.store_message(msg)\n    return memory, messages\n\n\nasync def test_retrieve_limit(memory_with_messages):\n    \"\"\"Test message retrieval with limit.\"\"\"\n    memory, messages = memory_with_messages\n\n    retrieved = await memory.retrieve_messages(limit=5)\n    assert len(retrieved) == 5\n</code></pre>"},{"location":"TESTING/#5-mark-tests-appropriately","title":"5. Mark Tests Appropriately","text":"<pre><code>@pytest.mark.postgresql\n@pytest.mark.slow\nasync def test_large_dataset_postgresql(postgresql_backend):\n    \"\"\"Test PostgreSQL with large dataset.\"\"\"\n    # This test:\n    # - Requires PostgreSQL (marked with postgresql)\n    # - Takes long time (marked with slow)\n    # - Can be skipped with: pytest -m \"not slow\"\n    pass\n</code></pre>"},{"location":"TESTING/#6-clean-up-resources","title":"6. Clean Up Resources","text":"<pre><code>async def test_with_cleanup():\n    \"\"\"Test with proper cleanup.\"\"\"\n    memory = MemoryFactory.create(\"sqlite\", database_path=\"test.db\")\n\n    try:\n        # Test code\n        await memory.store_message(message)\n    finally:\n        # Cleanup\n        await memory.disconnect()\n        Path(\"test.db\").unlink(missing_ok=True)\n</code></pre>"},{"location":"TESTING/#parameterized-tests","title":"Parameterized Tests","text":"<p>Test multiple scenarios with <code>pytest.mark.parametrize</code>:</p> <pre><code>@pytest.mark.parametrize(\"backend_type\", [\"sqlite\", \"postgresql\", \"redis\"])\nasync def test_all_backends(backend_type):\n    \"\"\"Test operation across all backends.\"\"\"\n    memory = MemoryFactory.create(backend_type)\n    result = await memory.some_operation()\n    assert result is not None\n\n\n@pytest.mark.parametrize(\"limit,expected\", [\n    (5, 5),\n    (10, 10),\n    (100, 50),  # Max available\n])\nasync def test_retrieve_limits(limit, expected):\n    \"\"\"Test different retrieval limits.\"\"\"\n    messages = await memory.retrieve_messages(limit=limit)\n    assert len(messages) == expected\n</code></pre>"},{"location":"TESTING/#coverage","title":"Coverage","text":""},{"location":"TESTING/#running-with-coverage","title":"Running with Coverage","text":"<pre><code># HTML report\npytest --cov=bruno_memory --cov-report=html\n\n# Terminal report\npytest --cov=bruno_memory --cov-report=term-missing\n\n# XML report (for CI)\npytest --cov=bruno_memory --cov-report=xml\n\n# Multiple reports\npytest --cov=bruno_memory --cov-report=html --cov-report=term-missing\n</code></pre>"},{"location":"TESTING/#viewing-coverage","title":"Viewing Coverage","text":"<pre><code># Open HTML report\nopen htmlcov/index.html  # Mac\nstart htmlcov/index.html  # Windows\nxdg-open htmlcov/index.html  # Linux\n</code></pre>"},{"location":"TESTING/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Overall: &gt; 80%</li> <li>Core modules: &gt; 90%</li> <li>Utilities: &gt; 70%</li> </ul>"},{"location":"TESTING/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"TESTING/#github-actions","title":"GitHub Actions","text":"<p>The <code>.github/workflows/docker-tests.yml</code> workflow:</p> <ol> <li>Matrix Testing: Tests across Python 3.10, 3.11, 3.12</li> <li>Service Setup: Starts all Docker services</li> <li>Backend Tests: Runs backend-specific test suites</li> <li>Coverage: Uploads to Codecov</li> <li>Artifacts: Saves coverage reports</li> </ol>"},{"location":"TESTING/#local-ci-simulation","title":"Local CI Simulation","text":"<p>Test like CI will:</p> <pre><code># Use CI profile\n.\\scripts\\run-tests-docker.ps1 -Profile ci\n\n# Or manually\ndocker-compose -f docker-compose.ci.yml up -d\npytest tests/ -v --cov=bruno_memory\ndocker-compose -f docker-compose.ci.yml down -v\n</code></pre>"},{"location":"TESTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"TESTING/#services-wont-start","title":"Services Won't Start","text":"<pre><code># Check Docker is running\ndocker ps\n\n# Check port conflicts\nnetstat -an | findstr \"5432 6379 8000 6333\"\n\n# View service logs\ndocker-compose logs &lt;service&gt;\n\n# Restart services\ndocker-compose restart &lt;service&gt;\n</code></pre>"},{"location":"TESTING/#tests-fail-to-connect","title":"Tests Fail to Connect","text":"<pre><code># Verify services are ready\n.\\scripts\\wait-for-services.ps1\n\n# Check environment variables\necho $env:POSTGRES_HOST\necho $env:REDIS_HOST\n\n# Test connections manually\n.\\scripts\\test-postgres-connection.ps1\n.\\scripts\\test-redis-connection.ps1\n</code></pre>"},{"location":"TESTING/#slow-tests","title":"Slow Tests","text":"<pre><code># Skip slow tests\npytest -m \"not slow\"\n\n# Run parallel tests (requires pytest-xdist)\npip install pytest-xdist\npytest -n auto\n\n# Profile tests\npytest --durations=10\n</code></pre>"},{"location":"TESTING/#port-conflicts","title":"Port Conflicts","text":"<pre><code># Change ports in .env\nPOSTGRES_PORT=5433\nREDIS_PORT=6380\n\n# Or use docker-compose override\ndocker-compose -f docker-compose.yml -f docker-compose.override.yml up\n</code></pre>"},{"location":"TESTING/#performance-testing","title":"Performance Testing","text":""},{"location":"TESTING/#benchmarks","title":"Benchmarks","text":"<pre><code># Run benchmark tests\npytest -m benchmark\n\n# With timing details\npytest --durations=0 -m benchmark\n</code></pre>"},{"location":"TESTING/#load-testing","title":"Load Testing","text":"<pre><code>@pytest.mark.benchmark\nasync def test_bulk_insert_performance():\n    \"\"\"Benchmark bulk message insertion.\"\"\"\n    memory = MemoryFactory.create(\"postgresql\")\n    messages = [create_test_message() for _ in range(1000)]\n\n    start = time.time()\n    for msg in messages:\n        await memory.store_message(msg)\n    duration = time.time() - start\n\n    # Should complete in under 5 seconds\n    assert duration &lt; 5.0\n</code></pre>"},{"location":"TESTING/#additional-resources","title":"Additional Resources","text":"<ul> <li>DOCKER_TESTING_QUICKSTART.md - Quick reference</li> <li>DOCKER_TESTING_PLAN.md - Implementation plan</li> <li>pytest documentation</li> <li>Docker Compose documentation</li> </ul>"},{"location":"TESTING/#getting-help","title":"Getting Help","text":"<ul> <li>Check existing tests for examples</li> <li>Review fixture implementations in <code>conftest.py</code></li> <li>Ask in GitHub Discussions</li> <li>Report issues on GitHub Issues</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to bruno-memory will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>Initial implementation of bruno-memory</li> <li>Multi-backend support (SQLite, PostgreSQL, Redis, ChromaDB, Qdrant)</li> <li>Factory pattern for backend creation</li> <li>Environment-based configuration</li> <li>Fallback chain support</li> <li>Entry point discovery for plugin backends</li> <li>Multi-level caching system (InMemoryCache, RedisCache, MultiLevelCache)</li> <li>Backup and export utilities (JSON, CSV, Excel)</li> <li>Analytics and performance tracking</li> <li>Conversation management</li> <li>Context building</li> <li>Memory retrieval</li> <li>Semantic search with vector backends</li> <li>Comprehensive test suite (&gt;90% coverage)</li> <li>Complete API documentation</li> <li>User guides and examples</li> </ul>"},{"location":"about/changelog/#features","title":"Features","text":""},{"location":"about/changelog/#backends","title":"Backends","text":"<ul> <li>SQLite: Lightweight, file-based storage with FTS support</li> <li>PostgreSQL: Enterprise-grade relational storage</li> <li>Redis: High-performance caching and session storage</li> <li>ChromaDB: Vector search for semantic similarity</li> <li>Qdrant: Production-grade vector search at scale</li> </ul>"},{"location":"about/changelog/#managers","title":"Managers","text":"<ul> <li>ConversationManager: Manage conversation threads</li> <li>ContextBuilder: Build intelligent conversation context</li> <li>MemoryRetriever: Retrieve and search memories</li> <li>EmbeddingManager: Generate and manage embeddings</li> <li>MemoryCompressor: Compress and summarize conversations</li> </ul>"},{"location":"about/changelog/#utilities","title":"Utilities","text":"<ul> <li>Cache: Multi-level caching with LRU and TTL</li> <li>Backup: Export to JSON, CSV, Excel formats</li> <li>Analytics: Conversation patterns and usage metrics</li> </ul>"},{"location":"about/changelog/#developer-experience","title":"Developer Experience","text":"<ul> <li>Type-safe with full type hints</li> <li>Pydantic validation</li> <li>Async/await support</li> <li>Comprehensive documentation</li> <li>Plugin architecture</li> <li>Testing utilities</li> </ul>"},{"location":"about/changelog/#010-initial-development","title":"0.1.0 - Initial Development","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Core architecture and base classes</li> <li>Initial backend implementations</li> <li>Basic documentation</li> </ul>"},{"location":"about/changelog/#release-notes-template","title":"Release Notes Template","text":"<pre><code>## [VERSION] - YYYY-MM-DD\n\n### Added\n- New features\n\n### Changed\n- Changes in existing functionality\n\n### Deprecated\n- Soon-to-be removed features\n\n### Removed\n- Removed features\n\n### Fixed\n- Bug fixes\n\n### Security\n- Security improvements\n</code></pre>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2024 meggy-ai</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>bruno-memory uses the following open-source packages:</p>"},{"location":"about/license/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>pydantic - MIT License</li> <li>bruno-core - MIT License</li> <li>bruno-llm - MIT License</li> </ul>"},{"location":"about/license/#backend-dependencies","title":"Backend Dependencies","text":"<ul> <li>aiosqlite - MIT License</li> <li>asyncpg - Apache License 2.0</li> <li>redis - MIT License</li> <li>chromadb - Apache License 2.0</li> <li>qdrant-client - Apache License 2.0</li> </ul>"},{"location":"about/license/#utility-dependencies","title":"Utility Dependencies","text":"<ul> <li>pandas - BSD 3-Clause License</li> <li>openpyxl - MIT License</li> <li>alembic - MIT License</li> <li>python-dotenv - BSD License</li> </ul>"},{"location":"about/license/#documentation-dependencies","title":"Documentation Dependencies","text":"<ul> <li>mkdocs - BSD 2-Clause License</li> <li>mkdocs-material - MIT License</li> <li>mkdocstrings - ISC License</li> </ul>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to bruno-memory, you agree that your contributions will be licensed under the MIT License.</p> <p>See CONTRIBUTING.md for more details.</p>"},{"location":"api/factory/","title":"Factory API","text":"<p>The factory provides a centralized way to create and manage memory backend instances.</p>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory","title":"bruno_memory.factory.MemoryBackendFactory","text":"<pre><code>MemoryBackendFactory(auto_discover: bool = True, load_env: bool = True)\n</code></pre> <p>Factory for creating memory backend instances.</p> <p>Initialize the factory with empty backend registry.</p> PARAMETER DESCRIPTION <code>auto_discover</code> <p>Automatically discover backends via entry points</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>load_env</code> <p>Load environment variables from .env file</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def __init__(self, auto_discover: bool = True, load_env: bool = True):\n    \"\"\"Initialize the factory with empty backend registry.\n\n    Args:\n        auto_discover: Automatically discover backends via entry points\n        load_env: Load environment variables from .env file\n    \"\"\"\n    self._backends: dict[str, type[BaseMemoryBackend]] = {}\n    self._config_types: dict[str, type[MemoryConfig]] = CONFIG_CLASSES.copy()\n\n    if load_env and DOTENV_AVAILABLE:\n        load_dotenv()\n        logger.info(\"Loaded environment variables from .env\")\n\n    if auto_discover:\n        self.discover_backends()\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.register_backend","title":"register_backend","text":"<pre><code>register_backend(name: str, backend_class: type[BaseMemoryBackend], config_class: type[MemoryConfig] | None = None) -&gt; None\n</code></pre> <p>Register a memory backend implementation.</p> PARAMETER DESCRIPTION <code>name</code> <p>Backend name (e.g., 'sqlite', 'postgresql')</p> <p> TYPE: <code>str</code> </p> <code>backend_class</code> <p>Backend implementation class</p> <p> TYPE: <code>type[BaseMemoryBackend]</code> </p> <code>config_class</code> <p>Optional configuration class override</p> <p> TYPE: <code>type[MemoryConfig] | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValidationError</code> <p>If backend class is invalid</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def register_backend(\n    self,\n    name: str,\n    backend_class: type[BaseMemoryBackend],\n    config_class: type[MemoryConfig] | None = None,\n) -&gt; None:\n    \"\"\"Register a memory backend implementation.\n\n    Args:\n        name: Backend name (e.g., 'sqlite', 'postgresql')\n        backend_class: Backend implementation class\n        config_class: Optional configuration class override\n\n    Raises:\n        ValidationError: If backend class is invalid\n    \"\"\"\n    if not inspect.isclass(backend_class):\n        raise ValidationError(f\"Backend must be a class, got {type(backend_class)}\")\n\n    if not issubclass(backend_class, BaseMemoryBackend):\n        raise ValidationError(\n            f\"Backend class must inherit from BaseMemoryBackend, \"\n            f\"got {backend_class.__name__}\"\n        )\n\n    self._backends[name] = backend_class\n\n    if config_class:\n        if not issubclass(config_class, MemoryConfig):\n            raise ValidationError(\n                f\"Config class must inherit from MemoryConfig, \" f\"got {config_class.__name__}\"\n            )\n        self._config_types[name] = config_class\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.unregister_backend","title":"unregister_backend","text":"<pre><code>unregister_backend(name: str) -&gt; None\n</code></pre> <p>Unregister a memory backend implementation.</p> PARAMETER DESCRIPTION <code>name</code> <p>Backend name to unregister</p> <p> TYPE: <code>str</code> </p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def unregister_backend(self, name: str) -&gt; None:\n    \"\"\"Unregister a memory backend implementation.\n\n    Args:\n        name: Backend name to unregister\n    \"\"\"\n    self._backends.pop(name, None)\n    self._config_types.pop(name, None)\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.discover_backends","title":"discover_backends","text":"<pre><code>discover_backends() -&gt; None\n</code></pre> <p>Discover and register backends via entry points.</p> <p>Looks for entry points in the 'bruno_memory.backends' group. Each entry point should provide a backend class.</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def discover_backends(self) -&gt; None:\n    \"\"\"Discover and register backends via entry points.\n\n    Looks for entry points in the 'bruno_memory.backends' group.\n    Each entry point should provide a backend class.\n    \"\"\"\n    try:\n        eps = entry_points()\n        # Handle both old and new entry_points() API\n        if hasattr(eps, \"select\"):\n            # Python 3.10+ API\n            backend_entries = eps.select(group=\"bruno_memory.backends\")\n        else:\n            # Python 3.9 API\n            backend_entries = eps.get(\"bruno_memory.backends\", [])\n\n        for ep in backend_entries:\n            try:\n                backend_class = ep.load()\n                # Entry point name is the backend name\n                self.register_backend(ep.name, backend_class)\n                logger.info(f\"Discovered backend via entry point: {ep.name}\")\n            except Exception as e:\n                logger.warning(f\"Failed to load backend entry point {ep.name}: {e}\")\n    except Exception as e:\n        logger.warning(f\"Backend discovery failed: {e}\")\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.create_backend","title":"create_backend","text":"<pre><code>create_backend(backend_type: str, config: MemoryConfig | None = None, **config_kwargs) -&gt; BaseMemoryBackend\n</code></pre> <p>Create a memory backend instance.</p> PARAMETER DESCRIPTION <code>backend_type</code> <p>Backend type name (e.g., 'sqlite', 'postgresql')</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Optional pre-created configuration instance</p> <p> TYPE: <code>MemoryConfig | None</code> DEFAULT: <code>None</code> </p> <code>**config_kwargs</code> <p>Configuration parameters (if config not provided)</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BaseMemoryBackend</code> <p>Configured backend instance</p> RAISES DESCRIPTION <code>BackendNotFoundError</code> <p>If backend type is not registered</p> <code>ConfigurationError</code> <p>If configuration is invalid</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_backend(\n    self, backend_type: str, config: MemoryConfig | None = None, **config_kwargs\n) -&gt; BaseMemoryBackend:\n    \"\"\"Create a memory backend instance.\n\n    Args:\n        backend_type: Backend type name (e.g., 'sqlite', 'postgresql')\n        config: Optional pre-created configuration instance\n        **config_kwargs: Configuration parameters (if config not provided)\n\n    Returns:\n        Configured backend instance\n\n    Raises:\n        BackendNotFoundError: If backend type is not registered\n        ConfigurationError: If configuration is invalid\n    \"\"\"\n    if backend_type not in self._backends:\n        available = list(self._backends.keys())\n        raise BackendNotFoundError(\n            f\"Backend type '{backend_type}' not found. \" f\"Available backends: {available}\"\n        )\n\n    # Create or validate configuration\n    if config is None:\n        config = self.create_config(backend_type, **config_kwargs)\n    else:\n        expected_type = self._config_types.get(backend_type)\n        if expected_type and not isinstance(config, expected_type):\n            raise ConfigurationError(\n                f\"Invalid config type for {backend_type}. \"\n                f\"Expected {expected_type.__name__}, got {type(config).__name__}\"\n            )\n\n    backend_class = self._backends[backend_type]\n\n    try:\n        return backend_class(config)\n    except Exception as e:\n        raise ConfigurationError(f\"Failed to create {backend_type} backend: {e}\")\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.create_config","title":"create_config","text":"<pre><code>create_config(backend_type: str, **kwargs) -&gt; MemoryConfig\n</code></pre> <p>Create a configuration instance for the specified backend type.</p> PARAMETER DESCRIPTION <code>backend_type</code> <p>Backend type name</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Configuration parameters</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>MemoryConfig</code> <p>Configuration instance for the backend</p> RAISES DESCRIPTION <code>BackendNotFoundError</code> <p>If backend type is not registered</p> <code>ConfigurationError</code> <p>If configuration creation fails</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_config(self, backend_type: str, **kwargs) -&gt; MemoryConfig:\n    \"\"\"Create a configuration instance for the specified backend type.\n\n    Args:\n        backend_type: Backend type name\n        **kwargs: Configuration parameters\n\n    Returns:\n        Configuration instance for the backend\n\n    Raises:\n        BackendNotFoundError: If backend type is not registered\n        ConfigurationError: If configuration creation fails\n    \"\"\"\n    if backend_type not in self._config_types:\n        available = list(self._config_types.keys())\n        raise BackendNotFoundError(\n            f\"Backend type '{backend_type}' not found. \" f\"Available backends: {available}\"\n        )\n\n    config_class = self._config_types[backend_type]\n\n    try:\n        return config_class(**kwargs)\n    except Exception as e:\n        raise ConfigurationError(f\"Failed to create {backend_type} configuration: {e}\")\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.create_from_env","title":"create_from_env","text":"<pre><code>create_from_env(backend_type_env: str = 'BRUNO_MEMORY_BACKEND', **config_overrides) -&gt; BaseMemoryBackend\n</code></pre> <p>Create a backend from environment variables.</p> PARAMETER DESCRIPTION <code>backend_type_env</code> <p>Environment variable name for backend type</p> <p> TYPE: <code>str</code> DEFAULT: <code>'BRUNO_MEMORY_BACKEND'</code> </p> <code>**config_overrides</code> <p>Override specific configuration values</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BaseMemoryBackend</code> <p>Configured backend instance</p> RAISES DESCRIPTION <code>ConfigurationError</code> <p>If environment configuration is invalid</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_from_env(\n    self, backend_type_env: str = \"BRUNO_MEMORY_BACKEND\", **config_overrides\n) -&gt; BaseMemoryBackend:\n    \"\"\"Create a backend from environment variables.\n\n    Args:\n        backend_type_env: Environment variable name for backend type\n        **config_overrides: Override specific configuration values\n\n    Returns:\n        Configured backend instance\n\n    Raises:\n        ConfigurationError: If environment configuration is invalid\n    \"\"\"\n    backend_type = os.getenv(backend_type_env)\n    if not backend_type:\n        raise ConfigurationError(\n            f\"Environment variable {backend_type_env} not set. \"\n            f\"Available backends: {list(self._backends.keys())}\"\n        )\n\n    # Get configuration class and extract env-based config\n    config_class = self.get_config_class(backend_type)\n\n    # Build config from environment\n    config_dict = {}\n    for field_name in config_class.model_fields.keys():\n        env_key = f\"BRUNO_MEMORY_{backend_type.upper()}_{field_name.upper()}\"\n        env_value = os.getenv(env_key)\n        if env_value is not None:\n            config_dict[field_name] = env_value\n\n    # Apply overrides\n    config_dict.update(config_overrides)\n\n    logger.info(f\"Creating {backend_type} backend from environment\")\n    return self.create_backend(backend_type, **config_dict)\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.create_with_fallback","title":"create_with_fallback","text":"<pre><code>create_with_fallback(backend_types: list[str], configs: list[MemoryConfig] | None = None, **common_config) -&gt; BaseMemoryBackend\n</code></pre> <p>Create a backend with fallback chain.</p> <p>Tries each backend in order until one succeeds.</p> PARAMETER DESCRIPTION <code>backend_types</code> <p>List of backend types to try in order</p> <p> TYPE: <code>list[str]</code> </p> <code>configs</code> <p>Optional list of pre-created configs (same order)</p> <p> TYPE: <code>list[MemoryConfig] | None</code> DEFAULT: <code>None</code> </p> <code>**common_config</code> <p>Common config parameters for all backends</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BaseMemoryBackend</code> <p>First successfully created backend</p> RAISES DESCRIPTION <code>ConfigurationError</code> <p>If all backends fail to create</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_with_fallback(\n    self,\n    backend_types: list[str],\n    configs: list[MemoryConfig] | None = None,\n    **common_config,\n) -&gt; BaseMemoryBackend:\n    \"\"\"Create a backend with fallback chain.\n\n    Tries each backend in order until one succeeds.\n\n    Args:\n        backend_types: List of backend types to try in order\n        configs: Optional list of pre-created configs (same order)\n        **common_config: Common config parameters for all backends\n\n    Returns:\n        First successfully created backend\n\n    Raises:\n        ConfigurationError: If all backends fail to create\n    \"\"\"\n    errors = []\n\n    for i, backend_type in enumerate(backend_types):\n        try:\n            config = configs[i] if configs and i &lt; len(configs) else None\n            backend = self.create_backend(backend_type, config=config, **common_config)\n            logger.info(f\"Successfully created {backend_type} backend\")\n            return backend\n        except Exception as e:\n            error_msg = f\"{backend_type}: {e}\"\n            errors.append(error_msg)\n            logger.warning(f\"Failed to create {backend_type} backend: {e}\")\n\n    raise ConfigurationError(\n        f\"All backends failed to create. Tried: {backend_types}. \"\n        f\"Errors: {'; '.join(errors)}\"\n    )\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.list_backends","title":"list_backends","text":"<pre><code>list_backends() -&gt; dict[str, str]\n</code></pre> <p>List all registered backend implementations.</p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary mapping backend names to class names</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def list_backends(self) -&gt; dict[str, str]:\n    \"\"\"List all registered backend implementations.\n\n    Returns:\n        Dictionary mapping backend names to class names\n    \"\"\"\n    return {name: cls.__name__ for name, cls in self._backends.items()}\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.get_backend_class","title":"get_backend_class","text":"<pre><code>get_backend_class(backend_type: str) -&gt; type[BaseMemoryBackend]\n</code></pre> <p>Get the backend class for a given type.</p> PARAMETER DESCRIPTION <code>backend_type</code> <p>Backend type name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>type[BaseMemoryBackend]</code> <p>Backend class</p> RAISES DESCRIPTION <code>BackendNotFoundError</code> <p>If backend type is not registered</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def get_backend_class(self, backend_type: str) -&gt; type[BaseMemoryBackend]:\n    \"\"\"Get the backend class for a given type.\n\n    Args:\n        backend_type: Backend type name\n\n    Returns:\n        Backend class\n\n    Raises:\n        BackendNotFoundError: If backend type is not registered\n    \"\"\"\n    if backend_type not in self._backends:\n        available = list(self._backends.keys())\n        raise BackendNotFoundError(\n            f\"Backend type '{backend_type}' not found. \" f\"Available backends: {available}\"\n        )\n\n    return self._backends[backend_type]\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.MemoryBackendFactory.get_config_class","title":"get_config_class","text":"<pre><code>get_config_class(backend_type: str) -&gt; type[MemoryConfig]\n</code></pre> <p>Get the configuration class for a given backend type.</p> PARAMETER DESCRIPTION <code>backend_type</code> <p>Backend type name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>type[MemoryConfig]</code> <p>Configuration class</p> RAISES DESCRIPTION <code>BackendNotFoundError</code> <p>If backend type is not registered</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def get_config_class(self, backend_type: str) -&gt; type[MemoryConfig]:\n    \"\"\"Get the configuration class for a given backend type.\n\n    Args:\n        backend_type: Backend type name\n\n    Returns:\n        Configuration class\n\n    Raises:\n        BackendNotFoundError: If backend type is not registered\n    \"\"\"\n    if backend_type not in self._config_types:\n        available = list(self._config_types.keys())\n        raise BackendNotFoundError(\n            f\"Backend type '{backend_type}' not found. \" f\"Available backends: {available}\"\n        )\n\n    return self._config_types[backend_type]\n</code></pre>"},{"location":"api/factory/#convenience-functions","title":"Convenience Functions","text":""},{"location":"api/factory/#bruno_memory.factory.create_backend","title":"bruno_memory.factory.create_backend","text":"<pre><code>create_backend(backend_type: str, config: MemoryConfig | None = None, **config_kwargs) -&gt; BaseMemoryBackend\n</code></pre> <p>Create a memory backend instance using the global factory.</p> PARAMETER DESCRIPTION <code>backend_type</code> <p>Backend type name</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Optional pre-created configuration instance</p> <p> TYPE: <code>MemoryConfig | None</code> DEFAULT: <code>None</code> </p> <code>**config_kwargs</code> <p>Configuration parameters</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BaseMemoryBackend</code> <p>Configured backend instance</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_backend(\n    backend_type: str, config: MemoryConfig | None = None, **config_kwargs\n) -&gt; BaseMemoryBackend:\n    \"\"\"Create a memory backend instance using the global factory.\n\n    Args:\n        backend_type: Backend type name\n        config: Optional pre-created configuration instance\n        **config_kwargs: Configuration parameters\n\n    Returns:\n        Configured backend instance\n    \"\"\"\n    return factory.create_backend(backend_type, config, **config_kwargs)\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.create_config","title":"bruno_memory.factory.create_config","text":"<pre><code>create_config(backend_type: str, **kwargs) -&gt; MemoryConfig\n</code></pre> <p>Create a configuration instance using the global factory.</p> PARAMETER DESCRIPTION <code>backend_type</code> <p>Backend type name</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Configuration parameters</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>MemoryConfig</code> <p>Configuration instance</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_config(backend_type: str, **kwargs) -&gt; MemoryConfig:\n    \"\"\"Create a configuration instance using the global factory.\n\n    Args:\n        backend_type: Backend type name\n        **kwargs: Configuration parameters\n\n    Returns:\n        Configuration instance\n    \"\"\"\n    return factory.create_config(backend_type, **kwargs)\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.create_from_env","title":"bruno_memory.factory.create_from_env","text":"<pre><code>create_from_env(backend_type_env: str = 'BRUNO_MEMORY_BACKEND', **config_overrides) -&gt; BaseMemoryBackend\n</code></pre> <p>Create a backend from environment variables using the global factory.</p> PARAMETER DESCRIPTION <code>backend_type_env</code> <p>Environment variable name for backend type</p> <p> TYPE: <code>str</code> DEFAULT: <code>'BRUNO_MEMORY_BACKEND'</code> </p> <code>**config_overrides</code> <p>Override specific configuration values</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BaseMemoryBackend</code> <p>Configured backend instance</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_from_env(\n    backend_type_env: str = \"BRUNO_MEMORY_BACKEND\", **config_overrides\n) -&gt; BaseMemoryBackend:\n    \"\"\"Create a backend from environment variables using the global factory.\n\n    Args:\n        backend_type_env: Environment variable name for backend type\n        **config_overrides: Override specific configuration values\n\n    Returns:\n        Configured backend instance\n    \"\"\"\n    return factory.create_from_env(backend_type_env, **config_overrides)\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.create_with_fallback","title":"bruno_memory.factory.create_with_fallback","text":"<pre><code>create_with_fallback(backend_types: list[str], configs: list[MemoryConfig] | None = None, **common_config) -&gt; BaseMemoryBackend\n</code></pre> <p>Create a backend with fallback chain using the global factory.</p> PARAMETER DESCRIPTION <code>backend_types</code> <p>List of backend types to try in order</p> <p> TYPE: <code>list[str]</code> </p> <code>configs</code> <p>Optional list of pre-created configs</p> <p> TYPE: <code>list[MemoryConfig] | None</code> DEFAULT: <code>None</code> </p> <code>**common_config</code> <p>Common config parameters</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BaseMemoryBackend</code> <p>First successfully created backend</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def create_with_fallback(\n    backend_types: list[str], configs: list[MemoryConfig] | None = None, **common_config\n) -&gt; BaseMemoryBackend:\n    \"\"\"Create a backend with fallback chain using the global factory.\n\n    Args:\n        backend_types: List of backend types to try in order\n        configs: Optional list of pre-created configs\n        **common_config: Common config parameters\n\n    Returns:\n        First successfully created backend\n    \"\"\"\n    return factory.create_with_fallback(backend_types, configs, **common_config)\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.list_backends","title":"bruno_memory.factory.list_backends","text":"<pre><code>list_backends() -&gt; dict[str, str]\n</code></pre> <p>List all registered backend implementations.</p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary mapping backend names to class names</p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def list_backends() -&gt; dict[str, str]:\n    \"\"\"List all registered backend implementations.\n\n    Returns:\n        Dictionary mapping backend names to class names\n    \"\"\"\n    return factory.list_backends()\n</code></pre>"},{"location":"api/factory/#bruno_memory.factory.register_backend","title":"bruno_memory.factory.register_backend","text":"<pre><code>register_backend(name: str, backend_class: type[BaseMemoryBackend], config_class: type[MemoryConfig] | None = None) -&gt; None\n</code></pre> <p>Register a memory backend implementation in the global factory.</p> PARAMETER DESCRIPTION <code>name</code> <p>Backend name</p> <p> TYPE: <code>str</code> </p> <code>backend_class</code> <p>Backend implementation class</p> <p> TYPE: <code>type[BaseMemoryBackend]</code> </p> <code>config_class</code> <p>Optional configuration class override</p> <p> TYPE: <code>type[MemoryConfig] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>bruno_memory/factory.py</code> <pre><code>def register_backend(\n    name: str,\n    backend_class: type[BaseMemoryBackend],\n    config_class: type[MemoryConfig] | None = None,\n) -&gt; None:\n    \"\"\"Register a memory backend implementation in the global factory.\n\n    Args:\n        name: Backend name\n        backend_class: Backend implementation class\n        config_class: Optional configuration class override\n    \"\"\"\n    factory.register_backend(name, backend_class, config_class)\n</code></pre>"},{"location":"api/factory/#global-factory-instance","title":"Global Factory Instance","text":"<p>The package provides a pre-configured global factory instance:</p> <pre><code>from bruno_memory import factory\n\n# Use the global factory\nbackends = factory.list_backends()\nbackend = factory.create_backend(\"sqlite\", database_path=\":memory:\")\n</code></pre>"},{"location":"api/factory/#examples","title":"Examples","text":""},{"location":"api/factory/#basic-usage","title":"Basic Usage","text":"<pre><code>from bruno_memory import create_backend\n\n# Create SQLite backend\nbackend = create_backend(\"sqlite\", database_path=\"memory.db\")\nawait backend.connect()\n</code></pre>"},{"location":"api/factory/#environment-configuration","title":"Environment Configuration","text":"<pre><code>from bruno_memory import create_from_env\nimport os\n\n# Set environment variables\nos.environ[\"BRUNO_MEMORY_BACKEND\"] = \"postgresql\"\nos.environ[\"BRUNO_MEMORY_POSTGRESQL_CONNECTION_STRING\"] = \"postgresql://...\"\n\n# Create from environment\nbackend = create_from_env()\n</code></pre>"},{"location":"api/factory/#fallback-chain","title":"Fallback Chain","text":"<pre><code>from bruno_memory import create_with_fallback\n\n# Try Redis first, fallback to SQLite\nbackend = create_with_fallback(\n    [\"redis\", \"sqlite\"],\n    database_path=\"fallback.db\"\n)\n</code></pre>"},{"location":"api/factory/#custom-backend-registration","title":"Custom Backend Registration","text":"<pre><code>from bruno_memory import register_backend\nfrom bruno_memory.base import BaseMemoryBackend, MemoryConfig\n\nclass MyConfig(MemoryConfig):\n    backend_type: str = \"custom\"\n    api_key: str\n\nclass MyBackend(BaseMemoryBackend):\n    async def connect(self):\n        ...\n    # Implement other methods...\n\n# Register custom backend\nregister_backend(\"custom\", MyBackend, MyConfig)\n\n# Now it can be created via factory\nbackend = create_backend(\"custom\", api_key=\"secret\")\n</code></pre>"},{"location":"api/factory/#backend-discovery","title":"Backend Discovery","text":"<p>The factory automatically discovers backends via:</p> <ol> <li>Built-in backends: Registered when importing <code>bruno_memory.backends</code></li> <li>Entry points: Third-party backends can register via entry points</li> </ol> <pre><code># pyproject.toml for a plugin\n[project.entry-points.\"bruno_memory.backends\"]\nmybackend = \"mypackage.backend:MyBackend\"\n</code></pre>"},{"location":"api/utils/cache/","title":"Cache Utilities","text":"<p>Multi-level caching system for high-performance memory access.</p>"},{"location":"api/utils/cache/#overview","title":"Overview","text":"<p>bruno-memory provides three cache implementations:</p> <ol> <li>InMemoryCache: LRU cache with TTL support</li> <li>RedisCache: Distributed caching with Redis</li> <li>MultiLevelCache: L1 (memory) + L2 (Redis) tiered caching</li> </ol>"},{"location":"api/utils/cache/#inmemorycache","title":"InMemoryCache","text":""},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache","title":"bruno_memory.utils.cache.InMemoryCache","text":"<pre><code>InMemoryCache(max_size: int = 1000, default_ttl: int | None = 3600, cleanup_interval: int = 60)\n</code></pre> <p>               Bases: <code>CacheInterface</code></p> <pre><code>\n              flowchart TD\n              bruno_memory.utils.cache.InMemoryCache[InMemoryCache]\n              bruno_memory.utils.cache.CacheInterface[CacheInterface]\n\n                              bruno_memory.utils.cache.CacheInterface --&gt; bruno_memory.utils.cache.InMemoryCache\n                \n\n\n              click bruno_memory.utils.cache.InMemoryCache href \"\" \"bruno_memory.utils.cache.InMemoryCache\"\n              click bruno_memory.utils.cache.CacheInterface href \"\" \"bruno_memory.utils.cache.CacheInterface\"\n            </code></pre> <p>In-memory LRU cache with TTL support.</p> <p>Features: - LRU eviction policy - TTL-based expiration - Thread-safe operations - Automatic cleanup of expired entries</p> <p>Initialize in-memory cache.</p> PARAMETER DESCRIPTION <code>max_size</code> <p>Maximum number of entries</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>default_ttl</code> <p>Default TTL in seconds (None = no expiration)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>3600</code> </p> <code>cleanup_interval</code> <p>Interval for cleanup task in seconds</p> <p> TYPE: <code>int</code> DEFAULT: <code>60</code> </p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>def __init__(\n    self, max_size: int = 1000, default_ttl: int | None = 3600, cleanup_interval: int = 60\n):\n    \"\"\"\n    Initialize in-memory cache.\n\n    Args:\n        max_size: Maximum number of entries\n        default_ttl: Default TTL in seconds (None = no expiration)\n        cleanup_interval: Interval for cleanup task in seconds\n    \"\"\"\n    self.max_size = max_size\n    self.default_ttl = default_ttl\n    self._cache: OrderedDict[str, tuple[Any, float | None]] = OrderedDict()\n    self._lock = asyncio.Lock()\n\n    # Statistics\n    self._hits = 0\n    self._misses = 0\n    self._evictions = 0\n    self._expirations = 0\n\n    # Start cleanup task\n    self._cleanup_task: asyncio.Task | None = None\n    self._cleanup_interval = cleanup_interval\n    self._running = False\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key: str) -&gt; Any | None\n</code></pre> <p>Get value from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get value from cache.\"\"\"\n    async with self._lock:\n        if key not in self._cache:\n            self._misses += 1\n            return None\n\n        value, expiry = self._cache[key]\n\n        # Check expiration\n        if self._is_expired(expiry):\n            del self._cache[key]\n            self._expirations += 1\n            self._misses += 1\n            return None\n\n        # Move to end (mark as recently used)\n        self._cache.move_to_end(key)\n        self._hits += 1\n        return value\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key: str, value: Any, ttl: int | None = None) -&gt; None\n</code></pre> <p>Set value in cache with optional TTL.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def set(self, key: str, value: Any, ttl: int | None = None) -&gt; None:\n    \"\"\"Set value in cache with optional TTL.\"\"\"\n    async with self._lock:\n        # Calculate expiry time\n        if ttl is None:\n            ttl = self.default_ttl\n\n        expiry = None if ttl is None else time.time() + ttl\n\n        # Update or add entry\n        if key in self._cache:\n            del self._cache[key]\n\n        self._cache[key] = (value, expiry)\n        self._cache.move_to_end(key)\n\n        # Evict oldest if over capacity\n        while len(self._cache) &gt; self.max_size:\n            oldest_key = next(iter(self._cache))\n            del self._cache[oldest_key]\n            self._evictions += 1\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key: str) -&gt; bool\n</code></pre> <p>Delete key from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def delete(self, key: str) -&gt; bool:\n    \"\"\"Delete key from cache.\"\"\"\n    async with self._lock:\n        if key in self._cache:\n            del self._cache[key]\n            return True\n        return False\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if key exists in cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if key exists in cache.\"\"\"\n    async with self._lock:\n        if key not in self._cache:\n            return False\n\n        _, expiry = self._cache[key]\n        if self._is_expired(expiry):\n            del self._cache[key]\n            self._expirations += 1\n            return False\n\n        return True\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.clear","title":"clear  <code>async</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all cache entries.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def clear(self) -&gt; None:\n    \"\"\"Clear all cache entries.\"\"\"\n    async with self._lock:\n        self._cache.clear()\n        logger.info(\"Cache cleared\")\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys: list[str]) -&gt; dict[str, Any]\n</code></pre> <p>Get multiple values from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def get_many(self, keys: list[str]) -&gt; dict[str, Any]:\n    \"\"\"Get multiple values from cache.\"\"\"\n    result = {}\n    for key in keys:\n        value = await self.get(key)\n        if value is not None:\n            result[key] = value\n    return result\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.InMemoryCache.set_many","title":"set_many  <code>async</code>","text":"<pre><code>set_many(items: dict[str, Any], ttl: int | None = None) -&gt; None\n</code></pre> <p>Set multiple values in cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def set_many(self, items: dict[str, Any], ttl: int | None = None) -&gt; None:\n    \"\"\"Set multiple values in cache.\"\"\"\n    for key, value in items.items():\n        await self.set(key, value, ttl)\n</code></pre>"},{"location":"api/utils/cache/#rediscache","title":"RedisCache","text":""},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache","title":"bruno_memory.utils.cache.RedisCache","text":"<pre><code>RedisCache(host: str = 'localhost', port: int = 6379, db: int = 0, password: str | None = None, prefix: str = 'bruno:cache:', default_ttl: int | None = 3600, max_connections: int = 10)\n</code></pre> <p>               Bases: <code>CacheInterface</code></p> <pre><code>\n              flowchart TD\n              bruno_memory.utils.cache.RedisCache[RedisCache]\n              bruno_memory.utils.cache.CacheInterface[CacheInterface]\n\n                              bruno_memory.utils.cache.CacheInterface --&gt; bruno_memory.utils.cache.RedisCache\n                \n\n\n              click bruno_memory.utils.cache.RedisCache href \"\" \"bruno_memory.utils.cache.RedisCache\"\n              click bruno_memory.utils.cache.CacheInterface href \"\" \"bruno_memory.utils.cache.CacheInterface\"\n            </code></pre> <p>Redis-based cache implementation.</p> <p>Features: - Distributed caching - Automatic TTL management - Connection pooling - Batch operations</p> <p>Initialize Redis cache.</p> PARAMETER DESCRIPTION <code>host</code> <p>Redis host</p> <p> TYPE: <code>str</code> DEFAULT: <code>'localhost'</code> </p> <code>port</code> <p>Redis port</p> <p> TYPE: <code>int</code> DEFAULT: <code>6379</code> </p> <code>db</code> <p>Redis database number</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>password</code> <p>Redis password</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>prefix</code> <p>Key prefix for namespacing</p> <p> TYPE: <code>str</code> DEFAULT: <code>'bruno:cache:'</code> </p> <code>default_ttl</code> <p>Default TTL in seconds</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>3600</code> </p> <code>max_connections</code> <p>Maximum connections in pool</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>def __init__(\n    self,\n    host: str = \"localhost\",\n    port: int = 6379,\n    db: int = 0,\n    password: str | None = None,\n    prefix: str = \"bruno:cache:\",\n    default_ttl: int | None = 3600,\n    max_connections: int = 10,\n):\n    \"\"\"\n    Initialize Redis cache.\n\n    Args:\n        host: Redis host\n        port: Redis port\n        db: Redis database number\n        password: Redis password\n        prefix: Key prefix for namespacing\n        default_ttl: Default TTL in seconds\n        max_connections: Maximum connections in pool\n    \"\"\"\n    if not REDIS_AVAILABLE:\n        raise ImportError(\"redis package is required for RedisCache\")\n\n    self.host = host\n    self.port = port\n    self.db = db\n    self.password = password\n    self.prefix = prefix\n    self.default_ttl = default_ttl\n    self.max_connections = max_connections\n\n    self._client: aioredis.Redis | None = None\n    self._connected = False\n\n    # Statistics (approximate, stored in Redis)\n    self._stats_key = f\"{prefix}stats\"\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Connect to Redis.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connect to Redis.\"\"\"\n    if self._connected:\n        return\n\n    try:\n        self._client = await aioredis.from_url(\n            f\"redis://{self.host}:{self.port}/{self.db}\",\n            password=self.password,\n            max_connections=self.max_connections,\n            decode_responses=False,\n        )\n\n        # Test connection\n        await self._client.ping()\n        self._connected = True\n        logger.info(f\"Connected to Redis at {self.host}:{self.port}\")\n\n    except Exception as e:\n        logger.error(f\"Failed to connect to Redis: {e}\")\n        raise CacheError(f\"Redis connection failed: {e}\")\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from Redis.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from Redis.\"\"\"\n    if self._client:\n        await self._client.close()\n        self._connected = False\n        logger.info(\"Disconnected from Redis\")\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key: str) -&gt; Any | None\n</code></pre> <p>Get value from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get value from cache.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        redis_key = self._make_key(key)\n        value = await self._client.get(redis_key)\n\n        if value is None:\n            await self._increment_stat(\"misses\")\n            return None\n\n        await self._increment_stat(\"hits\")\n        return json.loads(value)\n\n    except Exception as e:\n        logger.error(f\"Error getting key {key}: {e}\")\n        return None\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key: str, value: Any, ttl: int | None = None) -&gt; None\n</code></pre> <p>Set value in cache with optional TTL.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def set(self, key: str, value: Any, ttl: int | None = None) -&gt; None:\n    \"\"\"Set value in cache with optional TTL.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        redis_key = self._make_key(key)\n        serialized = json.dumps(value)\n\n        if ttl is None:\n            ttl = self.default_ttl\n\n        if ttl:\n            await self._client.setex(redis_key, ttl, serialized)\n        else:\n            await self._client.set(redis_key, serialized)\n\n    except Exception as e:\n        logger.error(f\"Error setting key {key}: {e}\")\n        raise CacheError(f\"Failed to set cache key: {e}\")\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key: str) -&gt; bool\n</code></pre> <p>Delete key from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def delete(self, key: str) -&gt; bool:\n    \"\"\"Delete key from cache.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        redis_key = self._make_key(key)\n        result = await self._client.delete(redis_key)\n        return result &gt; 0\n\n    except Exception as e:\n        logger.error(f\"Error deleting key {key}: {e}\")\n        return False\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if key exists in cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if key exists in cache.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        redis_key = self._make_key(key)\n        return await self._client.exists(redis_key) &gt; 0\n\n    except Exception as e:\n        logger.error(f\"Error checking key {key}: {e}\")\n        return False\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.clear","title":"clear  <code>async</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all cache entries with prefix.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def clear(self) -&gt; None:\n    \"\"\"Clear all cache entries with prefix.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        # Scan for all keys with prefix\n        cursor = 0\n        pattern = f\"{self.prefix}*\"\n\n        while True:\n            cursor, keys = await self._client.scan(cursor, match=pattern, count=100)\n\n            if keys:\n                await self._client.delete(*keys)\n\n            if cursor == 0:\n                break\n\n        logger.info(\"Redis cache cleared\")\n\n    except Exception as e:\n        logger.error(f\"Error clearing cache: {e}\")\n        raise CacheError(f\"Failed to clear cache: {e}\")\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys: list[str]) -&gt; dict[str, Any]\n</code></pre> <p>Get multiple values from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def get_many(self, keys: list[str]) -&gt; dict[str, Any]:\n    \"\"\"Get multiple values from cache.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        redis_keys = [self._make_key(k) for k in keys]\n        values = await self._client.mget(redis_keys)\n\n        result = {}\n        for key, value in zip(keys, values):\n            if value is not None:\n                result[key] = json.loads(value)\n                await self._increment_stat(\"hits\")\n            else:\n                await self._increment_stat(\"misses\")\n\n        return result\n\n    except Exception as e:\n        logger.error(f\"Error getting multiple keys: {e}\")\n        return {}\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.RedisCache.set_many","title":"set_many  <code>async</code>","text":"<pre><code>set_many(items: dict[str, Any], ttl: int | None = None) -&gt; None\n</code></pre> <p>Set multiple values in cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def set_many(self, items: dict[str, Any], ttl: int | None = None) -&gt; None:\n    \"\"\"Set multiple values in cache.\"\"\"\n    if not self._connected:\n        await self.connect()\n\n    try:\n        pipe = self._client.pipeline()\n\n        for key, value in items.items():\n            redis_key = self._make_key(key)\n            serialized = json.dumps(value)\n\n            if ttl is None:\n                ttl = self.default_ttl\n\n            if ttl:\n                pipe.setex(redis_key, ttl, serialized)\n            else:\n                pipe.set(redis_key, serialized)\n\n        await pipe.execute()\n\n    except Exception as e:\n        logger.error(f\"Error setting multiple keys: {e}\")\n        raise CacheError(f\"Failed to set multiple keys: {e}\")\n</code></pre>"},{"location":"api/utils/cache/#multilevelcache","title":"MultiLevelCache","text":""},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache","title":"bruno_memory.utils.cache.MultiLevelCache","text":"<pre><code>MultiLevelCache(l1_cache: InMemoryCache, l2_cache: RedisCache | None = None, promote_on_hit: bool = True)\n</code></pre> <p>               Bases: <code>CacheInterface</code></p> <pre><code>\n              flowchart TD\n              bruno_memory.utils.cache.MultiLevelCache[MultiLevelCache]\n              bruno_memory.utils.cache.CacheInterface[CacheInterface]\n\n                              bruno_memory.utils.cache.CacheInterface --&gt; bruno_memory.utils.cache.MultiLevelCache\n                \n\n\n              click bruno_memory.utils.cache.MultiLevelCache href \"\" \"bruno_memory.utils.cache.MultiLevelCache\"\n              click bruno_memory.utils.cache.CacheInterface href \"\" \"bruno_memory.utils.cache.CacheInterface\"\n            </code></pre> <p>Multi-level cache with L1 (in-memory) and L2 (Redis) tiers.</p> <p>Features: - Automatic promotion to L1 on access - Write-through to both levels - Fallback to L2 on L1 miss - Combined statistics</p> <p>Initialize multi-level cache.</p> PARAMETER DESCRIPTION <code>l1_cache</code> <p>L1 (in-memory) cache</p> <p> TYPE: <code>InMemoryCache</code> </p> <code>l2_cache</code> <p>L2 (Redis) cache (optional)</p> <p> TYPE: <code>RedisCache | None</code> DEFAULT: <code>None</code> </p> <code>promote_on_hit</code> <p>Promote L2 hits to L1</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>def __init__(\n    self,\n    l1_cache: InMemoryCache,\n    l2_cache: RedisCache | None = None,\n    promote_on_hit: bool = True,\n):\n    \"\"\"\n    Initialize multi-level cache.\n\n    Args:\n        l1_cache: L1 (in-memory) cache\n        l2_cache: L2 (Redis) cache (optional)\n        promote_on_hit: Promote L2 hits to L1\n    \"\"\"\n    self.l1 = l1_cache\n    self.l2 = l2_cache\n    self.promote_on_hit = promote_on_hit\n\n    logger.info(f\"MultiLevelCache initialized (L2: {l2_cache is not None})\")\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key: str) -&gt; Any | None\n</code></pre> <p>Get value from cache (L1 -&gt; L2).</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def get(self, key: str) -&gt; Any | None:\n    \"\"\"Get value from cache (L1 -&gt; L2).\"\"\"\n    # Try L1 first\n    value = await self.l1.get(key)\n    if value is not None:\n        return value\n\n    # Try L2 if available\n    if self.l2:\n        value = await self.l2.get(key)\n        if value is not None and self.promote_on_hit:\n            # Promote to L1\n            await self.l1.set(key, value)\n        return value\n\n    return None\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key: str, value: Any, ttl: int | None = None) -&gt; None\n</code></pre> <p>Set value in both cache levels.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def set(self, key: str, value: Any, ttl: int | None = None) -&gt; None:\n    \"\"\"Set value in both cache levels.\"\"\"\n    await self.l1.set(key, value, ttl)\n    if self.l2:\n        await self.l2.set(key, value, ttl)\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key: str) -&gt; bool\n</code></pre> <p>Delete key from both cache levels.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def delete(self, key: str) -&gt; bool:\n    \"\"\"Delete key from both cache levels.\"\"\"\n    l1_result = await self.l1.delete(key)\n    l2_result = await self.l2.delete(key) if self.l2 else False\n    return l1_result or l2_result\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if key exists in any cache level.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if key exists in any cache level.\"\"\"\n    if await self.l1.exists(key):\n        return True\n    if self.l2 and await self.l2.exists(key):\n        return True\n    return False\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.clear","title":"clear  <code>async</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all cache levels.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def clear(self) -&gt; None:\n    \"\"\"Clear all cache levels.\"\"\"\n    await self.l1.clear()\n    if self.l2:\n        await self.l2.clear()\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(keys: list[str]) -&gt; dict[str, Any]\n</code></pre> <p>Get multiple values from cache.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def get_many(self, keys: list[str]) -&gt; dict[str, Any]:\n    \"\"\"Get multiple values from cache.\"\"\"\n    # Try L1 first\n    result = await self.l1.get_many(keys)\n\n    # Find missing keys\n    if self.l2:\n        missing_keys = [k for k in keys if k not in result]\n        if missing_keys:\n            l2_results = await self.l2.get_many(missing_keys)\n            result.update(l2_results)\n\n            # Promote to L1\n            if self.promote_on_hit and l2_results:\n                await self.l1.set_many(l2_results)\n\n    return result\n</code></pre>"},{"location":"api/utils/cache/#bruno_memory.utils.cache.MultiLevelCache.set_many","title":"set_many  <code>async</code>","text":"<pre><code>set_many(items: dict[str, Any], ttl: int | None = None) -&gt; None\n</code></pre> <p>Set multiple values in both cache levels.</p> Source code in <code>bruno_memory/utils/cache.py</code> <pre><code>async def set_many(self, items: dict[str, Any], ttl: int | None = None) -&gt; None:\n    \"\"\"Set multiple values in both cache levels.\"\"\"\n    await self.l1.set_many(items, ttl)\n    if self.l2:\n        await self.l2.set_many(items, ttl)\n</code></pre>"},{"location":"api/utils/cache/#examples","title":"Examples","text":""},{"location":"api/utils/cache/#in-memory-caching","title":"In-Memory Caching","text":"<pre><code>from bruno_memory.utils import InMemoryCache\n\n# Create cache with max 1000 items\ncache = InMemoryCache(max_size=1000)\n\n# Set with TTL\nawait cache.set(\"key1\", \"value1\", ttl=300)  # 5 minutes\n\n# Get value\nvalue = await cache.get(\"key1\")\n\n# Batch operations\nawait cache.set_many({\n    \"key2\": \"value2\",\n    \"key3\": \"value3\"\n}, ttl=600)\n\nvalues = await cache.get_many([\"key1\", \"key2\", \"key3\"])\n\n# Statistics\nstats = cache.stats()\nprint(f\"Hit rate: {stats['hit_rate']:.2%}\")\n</code></pre>"},{"location":"api/utils/cache/#redis-caching","title":"Redis Caching","text":"<pre><code>from bruno_memory.utils import RedisCache\n\n# Create Redis cache\ncache = RedisCache(\n    host=\"localhost\",\n    port=6379,\n    prefix=\"myapp:\"\n)\n\nawait cache.connect()\n\n# Use same API as InMemoryCache\nawait cache.set(\"session:123\", user_data, ttl=3600)\ndata = await cache.get(\"session:123\")\n\nawait cache.disconnect()\n</code></pre>"},{"location":"api/utils/cache/#multi-level-caching","title":"Multi-Level Caching","text":"<pre><code>from bruno_memory.utils import (\n    MultiLevelCache,\n    InMemoryCache,\n    RedisCache\n)\n\n# Create tiered cache\ncache = MultiLevelCache(\n    l1_cache=InMemoryCache(max_size=100),  # Fast L1\n    l2_cache=RedisCache(host=\"localhost\")   # Distributed L2\n)\n\nawait cache.l2_cache.connect()\n\n# Checks L1 first, then L2, promotes to L1 on L2 hit\nvalue = await cache.get(\"key\")\n\n# Writes to both levels\nawait cache.set(\"key\", \"value\", ttl=300)\n\n# Combined statistics\nstats = cache.stats()\nprint(f\"L1 hits: {stats['l1_hits']}\")\nprint(f\"L2 hits: {stats['l2_hits']}\")\n\nawait cache.l2_cache.disconnect()\n</code></pre>"},{"location":"api/utils/cache/#integration-with-backend","title":"Integration with Backend","text":"<pre><code>from bruno_memory import create_backend\nfrom bruno_memory.utils import InMemoryCache\n\n# Create backend with caching\nbackend = create_backend(\"sqlite\", database_path=\"memory.db\")\ncache = InMemoryCache(max_size=500)\n\nawait backend.connect()\n\nasync def get_cached_messages(conv_id: str):\n    \"\"\"Get messages with caching.\"\"\"\n    cache_key = f\"messages:{conv_id}\"\n\n    # Try cache first\n    cached = await cache.get(cache_key)\n    if cached:\n        return cached\n\n    # Fallback to backend\n    messages = await backend.retrieve_messages(\n        conversation_id=conv_id,\n        limit=50\n    )\n\n    # Cache for 5 minutes\n    await cache.set(cache_key, messages, ttl=300)\n    return messages\n</code></pre>"},{"location":"api/utils/cache/#performance-tips","title":"Performance Tips","text":""},{"location":"api/utils/cache/#lru-eviction","title":"LRU Eviction","text":"<p>The in-memory cache uses LRU (Least Recently Used) eviction:</p> <pre><code>cache = InMemoryCache(max_size=100)\n\n# When cache is full, least recently accessed items are evicted\nfor i in range(150):\n    await cache.set(f\"key{i}\", f\"value{i}\")\n\n# Only last 100 items remain\n</code></pre>"},{"location":"api/utils/cache/#ttl-management","title":"TTL Management","text":"<p>Expired items are cleaned up automatically:</p> <pre><code>cache = InMemoryCache(\n    max_size=1000,\n    cleanup_interval=60  # Check every 60 seconds\n)\n\n# Set short TTL for temporary data\nawait cache.set(\"temp\", data, ttl=10)\n</code></pre>"},{"location":"api/utils/cache/#batch-operations","title":"Batch Operations","text":"<p>Use batch operations for better performance:</p> <pre><code># Slower: individual sets\nfor key, value in data.items():\n    await cache.set(key, value)\n\n# Faster: batch set\nawait cache.set_many(data, ttl=300)\n</code></pre>"},{"location":"api/utils/cache/#connection-pooling-redis","title":"Connection Pooling (Redis)","text":"<p>Redis cache uses connection pooling:</p> <pre><code>cache = RedisCache(\n    host=\"localhost\",\n    pool_size=10,  # Max 10 connections\n    max_overflow=5  # Allow 5 extra if needed\n)\n</code></pre>"},{"location":"api/utils/cache/#see-also","title":"See Also","text":"<ul> <li>Backend Selection - Choosing the right backend</li> <li>Performance Tuning - Optimization strategies</li> <li>Backup &amp; Analytics - Backup and analytics utilities</li> </ul>"},{"location":"development/contributing/","title":"Contributing Guide","text":"<p>See the main CONTRIBUTING.md file in the repository root for complete contributing guidelines.</p>"},{"location":"development/contributing/#quick-links","title":"Quick Links","text":"<ul> <li>Development Setup</li> <li>Project Structure</li> <li>Development Workflow</li> <li>Coding Standards</li> <li>Testing</li> <li>Backend Development</li> <li>Documentation</li> </ul>"},{"location":"development/contributing/#key-points","title":"Key Points","text":"<ol> <li>Fork and clone the repository</li> <li>Create a virtual environment and install dependencies</li> <li>Create a feature branch for your changes</li> <li>Write tests for new functionality</li> <li>Format and lint your code</li> <li>Submit a pull request with clear description</li> </ol>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and inclusive. We follow the Contributor Covenant.</p>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: GitHub Discussions</li> <li>Bugs: GitHub Issues</li> <li>Chat: Discord (link in README)</li> </ul> <p>Thank you for contributing! \ud83c\udf89</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with bruno-memory in just a few minutes!</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"BasicWith PostgreSQLWith Vector SearchAll Backends <pre><code>pip install bruno-memory\n</code></pre> <pre><code>pip install bruno-memory[postgresql]\n</code></pre> <pre><code>pip install bruno-memory[chromadb]\n# or\npip install bruno-memory[qdrant]\n</code></pre> <pre><code>pip install bruno-memory[all]\n</code></pre>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#1-create-a-backend","title":"1. Create a Backend","text":"<pre><code>from bruno_memory import create_backend\n\n# In-memory SQLite (development)\nbackend = create_backend(\"sqlite\", database_path=\":memory:\")\n\n# File-based SQLite (production)\nbackend = create_backend(\"sqlite\", database_path=\"./memory.db\")\n\n# PostgreSQL (enterprise)\nbackend = create_backend(\n    \"postgresql\",\n    connection_string=\"postgresql://user:pass@localhost/db\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#2-store-messages","title":"2. Store Messages","text":"<pre><code>import asyncio\nfrom bruno_core.models import Message, MessageRole, MessageType\n\nasync def store_conversation():\n    backend = create_backend(\"sqlite\", database_path=\"chat.db\")\n    await backend.connect()\n\n    # Create messages\n    messages = [\n        Message(\n            content=\"Hello! I need help with Python.\",\n            role=MessageRole.USER,\n            message_type=MessageType.TEXT\n        ),\n        Message(\n            content=\"I'd be happy to help! What would you like to know?\",\n            role=MessageRole.ASSISTANT,\n            message_type=MessageType.TEXT\n        )\n    ]\n\n    # Store them\n    for msg in messages:\n        await backend.store_message(msg)\n\n    print(f\"Stored {len(messages)} messages\")\n    await backend.disconnect()\n\nasyncio.run(store_conversation())\n</code></pre>"},{"location":"getting-started/quickstart/#3-retrieve-conversation-history","title":"3. Retrieve Conversation History","text":"<pre><code>async def get_history():\n    backend = create_backend(\"sqlite\", database_path=\"chat.db\")\n    await backend.connect()\n\n    # Get last 10 messages\n    messages = await backend.retrieve_messages(limit=10)\n\n    for msg in messages:\n        print(f\"{msg.role.value}: {msg.content}\")\n\n    # Get messages from specific conversation\n    messages = await backend.retrieve_messages(\n        conversation_id=\"conv-123\",\n        limit=50\n    )\n\n    await backend.disconnect()\n\nasyncio.run(get_history())\n</code></pre>"},{"location":"getting-started/quickstart/#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file:</p> <pre><code># Backend selection\nBRUNO_MEMORY_BACKEND=sqlite\n\n# SQLite configuration\nBRUNO_MEMORY_SQLITE_DATABASE_PATH=./memory.db\nBRUNO_MEMORY_SQLITE_ENABLE_FTS=true\n\n# PostgreSQL configuration (if using PostgreSQL)\n# BRUNO_MEMORY_POSTGRESQL_CONNECTION_STRING=postgresql://user:pass@localhost/db\n</code></pre> <p>Then load from environment:</p> <pre><code>from bruno_memory import create_from_env\n\n# Automatically loads from .env\nbackend = create_from_env()\nawait backend.connect()\n</code></pre>"},{"location":"getting-started/quickstart/#using-with-bruno-core","title":"Using with bruno-core","text":"<p>bruno-memory integrates seamlessly with bruno-core:</p> <pre><code>from bruno_core import BaseAssistant\nfrom bruno_memory import create_backend\n\nclass MyAssistant(BaseAssistant):\n    def __init__(self):\n        super().__init__(\n            name=\"my-assistant\",\n            model=\"gpt-4\"\n        )\n        # Initialize memory backend\n        self.memory = create_backend(\"sqlite\", database_path=\"assistant.db\")\n\n    async def process_message(self, content: str) -&gt; str:\n        # Store user message\n        user_msg = Message(\n            content=content,\n            role=MessageRole.USER,\n            message_type=MessageType.TEXT\n        )\n        await self.memory.store_message(user_msg)\n\n        # Get conversation context\n        history = await self.memory.retrieve_messages(limit=10)\n\n        # Generate response (using LLM)\n        response = await self.generate_response(history)\n\n        # Store assistant message\n        assistant_msg = Message(\n            content=response,\n            role=MessageRole.ASSISTANT,\n            message_type=MessageType.TEXT\n        )\n        await self.memory.store_message(assistant_msg)\n\n        return response\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Backend Selection: Choose the right backend for your needs</li> <li>Context Management: Build intelligent conversation context</li> <li>Semantic Search: Add vector search for RAG</li> <li>Caching: Optimize performance with caching</li> <li>Examples: More detailed examples</li> </ul>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#fallback-chain","title":"Fallback Chain","text":"<p>Try backends in order until one succeeds:</p> <pre><code>from bruno_memory import create_with_fallback\n\n# Try Redis first, fallback to SQLite\nbackend = create_with_fallback(\n    [\"redis\", \"sqlite\"],\n    database_path=\"fallback.db\"  # Used by SQLite\n)\n</code></pre>"},{"location":"getting-started/quickstart/#multi-level-caching","title":"Multi-Level Caching","text":"<pre><code>from bruno_memory.utils import MultiLevelCache, InMemoryCache, RedisCache\n\n# L1: In-memory, L2: Redis\ncache = MultiLevelCache(\n    l1_cache=InMemoryCache(max_size=100),\n    l2_cache=RedisCache(host=\"localhost\")\n)\n\nawait cache.set(\"key\", \"value\", ttl=300)\nvalue = await cache.get(\"key\")  # Checks L1 first, then L2\n</code></pre>"},{"location":"getting-started/quickstart/#backup-and-export","title":"Backup and Export","text":"<pre><code>from bruno_memory.utils import BackupExporter\n\nexporter = BackupExporter(output_dir=\"./backups\")\n\n# Export to JSON\nmessages = await backend.retrieve_messages(limit=1000)\nexporter.export_messages_to_json(messages)\n\n# Export to Excel\nexporter.export_messages_to_excel(messages)\n</code></pre>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#connection-issues","title":"Connection Issues","text":"<p>If you encounter connection issues:</p> <pre><code># Check backend health\nhealthy = await backend.health_check()\nif not healthy:\n    print(\"Backend not healthy!\")\n\n# Get connection statistics\nstats = await backend.get_statistics()\nprint(f\"Active connections: {stats.get('connections', 0)}\")\n</code></pre>"},{"location":"getting-started/quickstart/#performance","title":"Performance","text":"<p>For production workloads:</p> <pre><code># Enable connection pooling\nbackend = create_backend(\n    \"postgresql\",\n    connection_string=\"postgresql://...\",\n    pool_size=20,\n    max_overflow=10\n)\n\n# Use batch operations\nawait backend.store_messages_batch(messages)  # Faster than individual stores\n</code></pre>"},{"location":"getting-started/quickstart/#need-help","title":"Need Help?","text":"<ul> <li>\ud83d\udcd6 User Guide - Comprehensive guides</li> <li>\ud83d\udd0d API Reference - Detailed API docs</li> <li>\ud83d\udcac GitHub Issues - Report bugs or ask questions</li> <li>\ud83e\udd1d Contributing - Help improve bruno-memory</li> </ul>"},{"location":"guide/backends/","title":"Backend Selection Guide","text":"<p>Choose the right backend for your use case.</p>"},{"location":"guide/backends/#decision-tree","title":"Decision Tree","text":"<pre><code>graph TD\n    A[Start] --&gt; B{What's your primary need?}\n    B --&gt;|Simple/Development| C[SQLite]\n    B --&gt;|Production Scale| D{Need Vector Search?}\n    B --&gt;|High Performance Cache| E[Redis]\n    B --&gt;|Semantic Search/RAG| F{Which Vector DB?}\n\n    D --&gt;|Yes| F\n    D --&gt;|No| G[PostgreSQL]\n\n    F --&gt;|Ease of Use| H[ChromaDB]\n    F --&gt;|Performance/Scale| I[Qdrant]\n\n    C --&gt; J[\u2705 SQLite Backend]\n    E --&gt; K[\u2705 Redis Backend]\n    G --&gt; L[\u2705 PostgreSQL Backend]\n    H --&gt; M[\u2705 ChromaDB Backend]\n    I --&gt; N[\u2705 Qdrant Backend]</code></pre>"},{"location":"guide/backends/#sqlite","title":"SQLite","text":"<p>Best for: Development, small applications, embedded systems</p>"},{"location":"guide/backends/#pros","title":"Pros","text":"<ul> <li>\u2705 Zero configuration</li> <li>\u2705 File-based or in-memory</li> <li>\u2705 Full-text search support</li> <li>\u2705 Perfect for development</li> <li>\u2705 No separate server needed</li> </ul>"},{"location":"guide/backends/#cons","title":"Cons","text":"<ul> <li>\u274c Limited concurrency</li> <li>\u274c No distributed support</li> <li>\u274c No vector search</li> <li>\u274c Not ideal for high-traffic production</li> </ul>"},{"location":"guide/backends/#usage","title":"Usage","text":"<pre><code>from bruno_memory import create_backend\n\n# In-memory (fastest, for testing)\nbackend = create_backend(\"sqlite\", database_path=\":memory:\")\n\n# File-based (persistent)\nbackend = create_backend(\n    \"sqlite\",\n    database_path=\"./memory.db\",\n    enable_fts=True  # Enable full-text search\n)\n</code></pre>"},{"location":"guide/backends/#when-to-use","title":"When to Use","text":"<ul> <li>Local development</li> <li>Single-user applications</li> <li>Embedded applications</li> <li>Testing</li> <li>POC/prototypes</li> </ul>"},{"location":"guide/backends/#postgresql","title":"PostgreSQL","text":"<p>Best for: Production applications, multi-user systems, enterprise</p>"},{"location":"guide/backends/#pros_1","title":"Pros","text":"<ul> <li>\u2705 Excellent performance at scale</li> <li>\u2705 ACID compliance</li> <li>\u2705 Connection pooling</li> <li>\u2705 Full-text search</li> <li>\u2705 Concurrent access</li> <li>\u2705 Proven reliability</li> </ul>"},{"location":"guide/backends/#cons_1","title":"Cons","text":"<ul> <li>\u274c Requires separate server</li> <li>\u274c More complex setup</li> <li>\u274c No built-in vector search</li> <li>\u274c Higher resource usage</li> </ul>"},{"location":"guide/backends/#usage_1","title":"Usage","text":"<pre><code>from bruno_memory import create_backend\n\nbackend = create_backend(\n    \"postgresql\",\n    connection_string=\"postgresql://user:pass@localhost:5432/memory\",\n    pool_size=20,  # Connection pool\n    enable_fts=True\n)\n</code></pre>"},{"location":"guide/backends/#when-to-use_1","title":"When to Use","text":"<ul> <li>Production applications</li> <li>Multi-user systems</li> <li>High-traffic scenarios</li> <li>When you need reliability</li> <li>Enterprise deployments</li> </ul>"},{"location":"guide/backends/#docker-setup","title":"Docker Setup","text":"<pre><code># Run PostgreSQL in Docker\ndocker run -d \\\n  --name postgres \\\n  -e POSTGRES_PASSWORD=password \\\n  -e POSTGRES_DB=memory \\\n  -p 5432:5432 \\\n  postgres:15\n</code></pre>"},{"location":"guide/backends/#redis","title":"Redis","text":"<p>Best for: High-performance caching, session storage, temporary data</p>"},{"location":"guide/backends/#pros_2","title":"Pros","text":"<ul> <li>\u2705 Extremely fast (in-memory)</li> <li>\u2705 TTL support</li> <li>\u2705 Distributed caching</li> <li>\u2705 Pub/sub capabilities</li> <li>\u2705 Perfect for session data</li> </ul>"},{"location":"guide/backends/#cons_2","title":"Cons","text":"<ul> <li>\u274c Memory-only (ephemeral)</li> <li>\u274c Not for primary storage</li> <li>\u274c No complex queries</li> <li>\u274c Limited search capabilities</li> </ul>"},{"location":"guide/backends/#usage_2","title":"Usage","text":"<pre><code>from bruno_memory import create_backend\n\nbackend = create_backend(\n    \"redis\",\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    ttl=3600  # Default TTL: 1 hour\n)\n</code></pre>"},{"location":"guide/backends/#when-to-use_2","title":"When to Use","text":"<ul> <li>Caching layer</li> <li>Session storage</li> <li>Temporary conversation state</li> <li>Rate limiting</li> <li>Real-time features</li> </ul>"},{"location":"guide/backends/#docker-setup_1","title":"Docker Setup","text":"<pre><code># Run Redis in Docker\ndocker run -d \\\n  --name redis \\\n  -p 6379:6379 \\\n  redis:7\n</code></pre>"},{"location":"guide/backends/#chromadb","title":"ChromaDB","text":"<p>Best for: RAG applications, semantic search, local vector search</p>"},{"location":"guide/backends/#pros_3","title":"Pros","text":"<ul> <li>\u2705 Easy setup</li> <li>\u2705 Built for embeddings</li> <li>\u2705 Excellent for RAG</li> <li>\u2705 Local or client-server</li> <li>\u2705 Good Python integration</li> </ul>"},{"location":"guide/backends/#cons_3","title":"Cons","text":"<ul> <li>\u274c Newer/less mature</li> <li>\u274c Limited at massive scale</li> <li>\u274c No full-text search</li> <li>\u274c Python-centric</li> </ul>"},{"location":"guide/backends/#usage_3","title":"Usage","text":"<pre><code>from bruno_memory import create_backend\n\n# Local mode\nbackend = create_backend(\n    \"chromadb\",\n    persist_directory=\"./chroma_db\",\n    embedding_function=\"text-embedding-3-small\"\n)\n\n# Client-server mode\nbackend = create_backend(\n    \"chromadb\",\n    host=\"localhost\",\n    port=8000,\n    embedding_function=\"text-embedding-3-small\"\n)\n</code></pre>"},{"location":"guide/backends/#when-to-use_3","title":"When to Use","text":"<ul> <li>RAG applications</li> <li>Semantic search</li> <li>Local vector search</li> <li>Development with vectors</li> <li>Quick prototyping</li> </ul>"},{"location":"guide/backends/#docker-setup_2","title":"Docker Setup","text":"<pre><code># Run ChromaDB in Docker\ndocker run -d \\\n  --name chromadb \\\n  -p 8000:8000 \\\n  -v ./chroma_data:/chroma/chroma \\\n  chromadb/chroma:latest\n</code></pre>"},{"location":"guide/backends/#qdrant","title":"Qdrant","text":"<p>Best for: Production vector search, large-scale RAG, high performance</p>"},{"location":"guide/backends/#pros_4","title":"Pros","text":"<ul> <li>\u2705 Highly scalable</li> <li>\u2705 Excellent performance</li> <li>\u2705 Rich filtering</li> <li>\u2705 Production-ready</li> <li>\u2705 Cloud and self-hosted</li> </ul>"},{"location":"guide/backends/#cons_4","title":"Cons","text":"<ul> <li>\u274c More complex setup</li> <li>\u274c Requires separate server</li> <li>\u274c No full-text search</li> <li>\u274c Steeper learning curve</li> </ul>"},{"location":"guide/backends/#usage_4","title":"Usage","text":"<pre><code>from bruno_memory import create_backend\n\nbackend = create_backend(\n    \"qdrant\",\n    host=\"localhost\",\n    port=6333,\n    collection_name=\"bruno_memory\",\n    embedding_function=\"text-embedding-3-small\"\n)\n</code></pre>"},{"location":"guide/backends/#when-to-use_4","title":"When to Use","text":"<ul> <li>Production RAG systems</li> <li>Large-scale vector search</li> <li>High-performance requirements</li> <li>When you need advanced filtering</li> <li>Cloud-native deployments</li> </ul>"},{"location":"guide/backends/#docker-setup_3","title":"Docker Setup","text":"<pre><code># Run Qdrant in Docker\ndocker run -d \\\n  --name qdrant \\\n  -p 6333:6333 \\\n  -v ./qdrant_storage:/qdrant/storage \\\n  qdrant/qdrant:latest\n</code></pre>"},{"location":"guide/backends/#hybrid-approaches","title":"Hybrid Approaches","text":""},{"location":"guide/backends/#sqlite-chromadb","title":"SQLite + ChromaDB","text":"<pre><code>from bruno_memory import create_backend\n\n# SQLite for structured data\nstructured = create_backend(\"sqlite\", database_path=\"./data.db\")\n\n# ChromaDB for vectors\nvectors = create_backend(\n    \"chromadb\",\n    persist_directory=\"./vectors\",\n    embedding_function=\"text-embedding-3-small\"\n)\n\n# Use both together\nawait structured.store_message(message)\nawait vectors.store_memory(memory_with_embedding)\n</code></pre>"},{"location":"guide/backends/#postgresql-qdrant","title":"PostgreSQL + Qdrant","text":"<pre><code># PostgreSQL for primary storage\nprimary = create_backend(\n    \"postgresql\",\n    connection_string=\"postgresql://...\"\n)\n\n# Qdrant for semantic search\nsemantic = create_backend(\n    \"qdrant\",\n    host=\"localhost\",\n    port=6333\n)\n\n# Store in both\nawait primary.store_message(message)\nif message.embedding:\n    await semantic.store_memory(memory_from_message)\n</code></pre>"},{"location":"guide/backends/#redis-postgresql-with-fallback","title":"Redis + PostgreSQL (with Fallback)","text":"<pre><code>from bruno_memory import create_with_fallback\n\n# Try Redis (fast), fallback to PostgreSQL\nbackend = create_with_fallback(\n    [\"redis\", \"postgresql\"],\n    host=\"localhost\",  # Used by Redis\n    connection_string=\"postgresql://...\"  # Used by PostgreSQL\n)\n</code></pre>"},{"location":"guide/backends/#comparison-table","title":"Comparison Table","text":"Feature SQLite PostgreSQL Redis ChromaDB Qdrant Setup Complexity \u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50 Performance \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Scalability \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Concurrency \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Persistence \u2705 \u2705 \u26a0\ufe0f \u2705 \u2705 Vector Search \u274c \u274c \u274c \u2705 \u2705 Full-Text Search \u2705 \u2705 \u26a0\ufe0f \u274c \u274c Resource Usage Low Medium Medium Medium Medium-High Maintenance None Medium Low Low Medium <p>Legend: - \u2b50 = Fewer stars = easier/lighter - \u2705 = Supported - \u274c = Not supported - \u26a0\ufe0f = Limited support</p>"},{"location":"guide/backends/#migration-path","title":"Migration Path","text":"<p>Typical progression:</p> <pre><code>graph LR\n    A[SQLite&lt;br/&gt;Development] --&gt; B[PostgreSQL&lt;br/&gt;Production]\n    B --&gt; C[+ Redis&lt;br/&gt;Caching]\n    C --&gt; D[+ Qdrant&lt;br/&gt;RAG/Semantic]</code></pre>"},{"location":"guide/backends/#recommendations-by-use-case","title":"Recommendations by Use Case","text":""},{"location":"guide/backends/#personal-assistant","title":"Personal Assistant","text":"<ul> <li>Start: SQLite</li> <li>Scale: PostgreSQL</li> <li>+ Semantic: ChromaDB</li> </ul>"},{"location":"guide/backends/#enterprise-chatbot","title":"Enterprise Chatbot","text":"<ul> <li>Primary: PostgreSQL</li> <li>Cache: Redis</li> <li>Semantic: Qdrant</li> </ul>"},{"location":"guide/backends/#rag-application","title":"RAG Application","text":"<ul> <li>Primary: Qdrant or ChromaDB</li> <li>Metadata: PostgreSQL (optional)</li> </ul>"},{"location":"guide/backends/#multi-tenant-saas","title":"Multi-Tenant SaaS","text":"<ul> <li>Primary: PostgreSQL (with tenant isolation)</li> <li>Cache: Redis (with tenant prefixes)</li> <li>Semantic: Qdrant (with tenant collections)</li> </ul>"},{"location":"guide/backends/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Get started with your chosen backend</li> <li>Configuration - Configure your backend</li> <li>Performance Tuning - Optimize for your use case</li> <li>API Reference - Detailed backend APIs</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/","title":"CI/CD Implementation Guide","text":"<p>This document describes the CI/CD infrastructure for bruno-memory.</p>"},{"location":"how-to/CI_CD_GUIDE/#overview","title":"Overview","text":"<p>The project uses GitHub Actions for continuous integration, testing, and deployment. The workflow is designed to ensure code quality, security, and reliable releases.</p>"},{"location":"how-to/CI_CD_GUIDE/#workflows","title":"Workflows","text":""},{"location":"how-to/CI_CD_GUIDE/#1-ci-workflow-githubworkflowsciyml","title":"1. CI Workflow (<code>.github/workflows/ci.yml</code>)","text":"<p>Trigger: Push to main/develop, Pull Requests</p> <p>Jobs: - Test Matrix:    - Python versions: 3.10, 3.11, 3.12   - Operating systems: Ubuntu, Windows, macOS   - Runs full test suite with coverage reporting</p> <ul> <li>Backend Integration Tests:</li> <li>PostgreSQL 16 + Redis 7 services</li> <li> <p>Tests backend-specific functionality</p> </li> <li> <p>Documentation Build:</p> </li> <li>Validates MkDocs can build successfully</li> <li>Uploads docs artifact</li> </ul> <p>Coverage: Uploads to Codecov for tracking</p>"},{"location":"how-to/CI_CD_GUIDE/#2-lint-workflow-githubworkflowslintyml","title":"2. Lint Workflow (<code>.github/workflows/lint.yml</code>)","text":"<p>Trigger: Push to main/develop, Pull Requests</p> <p>Checks: - Black: Code formatting - Ruff: Linting and import sorting - Mypy: Type checking (continue on error) - Bandit: Security scanning (continue on error)</p>"},{"location":"how-to/CI_CD_GUIDE/#3-publish-workflow-githubworkflowspublishyml","title":"3. Publish Workflow (<code>.github/workflows/publish.yml</code>)","text":"<p>Trigger:  - Release published (automatic to PyPI) - Manual dispatch (choose TestPyPI or PyPI)</p> <p>Process: 1. Build distribution packages (wheel + sdist) 2. Validate with twine 3. Publish to PyPI using trusted publishing (OIDC)</p> <p>Requirements: - Configure PyPI trusted publisher - Set up GitHub environments (testpypi, pypi)</p>"},{"location":"how-to/CI_CD_GUIDE/#4-release-workflow-githubworkflowsreleaseyml","title":"4. Release Workflow (<code>.github/workflows/release.yml</code>)","text":"<p>Trigger: Git tag push (v..*)</p> <p>Process: 1. Generate changelog from commits 2. Build distribution packages 3. Create GitHub Release with artifacts 4. Deploy documentation to GitHub Pages 5. Announcement placeholder</p>"},{"location":"how-to/CI_CD_GUIDE/#5-dependency-check-githubworkflowsdependenciesyml","title":"5. Dependency Check (<code>.github/workflows/dependencies.yml</code>)","text":"<p>Trigger:  - Weekly schedule (Monday 9 AM UTC) - Pull requests touching dependencies - Manual dispatch</p> <p>Checks: - pip-audit: Security vulnerabilities in dependencies - Dependency Review: GitHub's dependency review action - Outdated Packages: Creates issues for updates</p>"},{"location":"how-to/CI_CD_GUIDE/#configuration-files","title":"Configuration Files","text":""},{"location":"how-to/CI_CD_GUIDE/#codecovyml","title":"codecov.yml","text":"<p>Coverage Targets: - Project: 60% (threshold: 1%) - Patch: 70% (threshold: 5%)</p> <p>Components: - Backends - Managers - Utils</p>"},{"location":"how-to/CI_CD_GUIDE/#pre-commit-configyaml","title":".pre-commit-config.yaml","text":"<p>Pre-commit Hooks: - Trailing whitespace, EOF fixes - YAML/JSON/TOML validation - Black formatting - Ruff linting - Mypy type checking - Bandit security scanning - Markdown formatting</p> <p>Setup: <pre><code>pip install pre-commit\npre-commit install\n</code></pre></p>"},{"location":"how-to/CI_CD_GUIDE/#pyprojecttoml","title":"pyproject.toml","text":"<p>Tool Configurations: - Black: 100 char line length - Ruff: E, W, F, I, B, C4, UP, ARG, SIM rules - Mypy: Strict mode with third-party ignores - Pytest: Coverage reporting, markers - Coverage: Exclude patterns</p>"},{"location":"how-to/CI_CD_GUIDE/#makefile-commands","title":"Makefile Commands","text":"<p>Quick access to common tasks:</p> <pre><code>make install-dev    # Install with dev dependencies\nmake test          # Run tests with coverage\nmake test-fast     # Skip slow backend tests\nmake lint          # Check code quality\nmake format        # Auto-format code\nmake type-check    # Run mypy\nmake docs          # Build documentation\nmake docs-serve    # Serve docs locally\nmake build         # Build distribution\nmake publish       # Publish to PyPI\nmake bump-patch    # Bump patch version\nmake bump-minor    # Bump minor version\nmake bump-major    # Bump major version\n</code></pre>"},{"location":"how-to/CI_CD_GUIDE/#version-bumping","title":"Version Bumping","text":""},{"location":"how-to/CI_CD_GUIDE/#automated-script-scriptsbump_versionpy","title":"Automated Script (<code>scripts/bump_version.py</code>)","text":"<pre><code># Bump version and create git tag\npython scripts/bump_version.py patch  # 0.1.0 -&gt; 0.1.1\npython scripts/bump_version.py minor  # 0.1.0 -&gt; 0.2.0\npython scripts/bump_version.py major  # 0.1.0 -&gt; 1.0.0\n\n# Options\n--dry-run       # Show what would happen\n--no-commit     # Don't create git commit\n--no-tag        # Don't create git tag\n</code></pre> <p>Updates: - <code>pyproject.toml</code> version - <code>bruno_memory/__init__.py</code> version - Creates git commit and tag</p>"},{"location":"how-to/CI_CD_GUIDE/#github-setup-requirements","title":"GitHub Setup Requirements","text":""},{"location":"how-to/CI_CD_GUIDE/#1-repository-settings","title":"1. Repository Settings","text":"<p>Secrets (not needed with OIDC): - None required for trusted publishing</p> <p>Environments: - <code>testpypi</code>: For testing releases - <code>pypi</code>: For production releases</p> <p>Branch Protection: - Require status checks to pass - Require pull request reviews - Restrict push to main</p>"},{"location":"how-to/CI_CD_GUIDE/#2-pypi-trusted-publishing","title":"2. PyPI Trusted Publishing","text":"<p>Setup on PyPI: 1. Go to PyPI project settings 2. Publishing -&gt; Add publisher 3. Configure:    - Owner: meggy-ai    - Repository: bruno-memory    - Workflow: publish.yml    - Environment: pypi</p> <p>Setup on TestPyPI (optional): - Same process on test.pypi.org</p>"},{"location":"how-to/CI_CD_GUIDE/#3-codecov-integration","title":"3. Codecov Integration","text":"<ol> <li>Sign up at codecov.io</li> <li>Connect GitHub repository</li> <li>Copy upload token</li> <li>Add as repository secret: <code>CODECOV_TOKEN</code></li> </ol>"},{"location":"how-to/CI_CD_GUIDE/#4-github-pages","title":"4. GitHub Pages","text":"<p>Enable in Settings: - Source: GitHub Actions - Custom domain (optional)</p>"},{"location":"how-to/CI_CD_GUIDE/#release-process","title":"Release Process","text":""},{"location":"how-to/CI_CD_GUIDE/#standard-release","title":"Standard Release","text":"<pre><code># 1. Update version and changelog\npython scripts/bump_version.py minor\n# Edit CHANGELOG.md\n\n# 2. Commit and push\ngit add .\ngit commit -m \"Release v0.2.0\"\ngit push origin main\n\n# 3. Push tag (triggers release)\ngit push origin v0.2.0\n</code></pre>"},{"location":"how-to/CI_CD_GUIDE/#hotfix-release","title":"Hotfix Release","text":"<pre><code># 1. Create hotfix branch\ngit checkout -b hotfix/v0.1.1 v0.1.0\n\n# 2. Fix issue and bump patch\npython scripts/bump_version.py patch\n\n# 3. Merge and release\ngit checkout main\ngit merge hotfix/v0.1.1\ngit push origin main v0.1.1\n</code></pre>"},{"location":"how-to/CI_CD_GUIDE/#monitoring","title":"Monitoring","text":""},{"location":"how-to/CI_CD_GUIDE/#github-actions","title":"GitHub Actions","text":"<ul> <li>Check workflow runs: github.com/meggy-ai/bruno-memory/actions</li> <li>Review failed builds immediately</li> <li>Check for security advisories</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#codecov-dashboard","title":"Codecov Dashboard","text":"<ul> <li>Monitor coverage trends</li> <li>Review coverage reports on PRs</li> <li>Ensure coverage doesn't decrease</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#pypi-stats","title":"PyPI Stats","text":"<ul> <li>Monitor download statistics</li> <li>Check for reported issues</li> <li>Review dependency status</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#security","title":"Security","text":""},{"location":"how-to/CI_CD_GUIDE/#dependency-scanning","title":"Dependency Scanning","text":"<ul> <li>Weekly automated scans</li> <li>pip-audit for vulnerabilities</li> <li>Dependabot alerts enabled</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#code-scanning","title":"Code Scanning","text":"<ul> <li>Bandit for Python security issues</li> <li>Pre-commit hooks prevent commits</li> <li>Manual review for security PRs</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#secret-management","title":"Secret Management","text":"<ul> <li>No secrets in code (gitignore)</li> <li>Use GitHub secrets for CI/CD</li> <li>Rotate secrets regularly</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/CI_CD_GUIDE/#failed-tests","title":"Failed Tests","text":"<pre><code># Run specific test\npytest tests/unit/test_factory.py -v\n\n# Run with full output\npytest tests/ -vv --tb=long\n\n# Skip slow tests\npytest tests/ -m \"not slow\"\n</code></pre>"},{"location":"how-to/CI_CD_GUIDE/#failed-builds","title":"Failed Builds","text":"<pre><code># Check linting locally\nmake lint\n\n# Fix formatting\nmake format\n\n# Type check\nmake type-check\n</code></pre>"},{"location":"how-to/CI_CD_GUIDE/#failed-deployments","title":"Failed Deployments","text":"<ul> <li>Check PyPI trusted publishing config</li> <li>Verify environment permissions</li> <li>Review workflow logs</li> <li>Check package build: <code>python -m build</code></li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#continuous-improvement","title":"Continuous Improvement","text":""},{"location":"how-to/CI_CD_GUIDE/#metrics-to-track","title":"Metrics to Track","text":"<ul> <li>Test coverage percentage</li> <li>Build success rate</li> <li>Time to release</li> <li>Security vulnerabilities found</li> <li>Code quality scores</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#regular-maintenance","title":"Regular Maintenance","text":"<ul> <li>Update GitHub Actions versions</li> <li>Update Python versions tested</li> <li>Review and update dependencies</li> <li>Improve test coverage</li> <li>Optimize build times</li> </ul>"},{"location":"how-to/CI_CD_GUIDE/#resources","title":"Resources","text":"<ul> <li>GitHub Actions Documentation</li> <li>PyPI Trusted Publishing</li> <li>Codecov Documentation</li> <li>Pre-commit Documentation</li> <li>Semantic Versioning</li> </ul>"},{"location":"how-to/HOW_TO_RELEASE/","title":"How to Create a Release","text":"<p>This guide walks you through creating a new release of bruno-memory from start to finish.</p>"},{"location":"how-to/HOW_TO_RELEASE/#prerequisites","title":"Prerequisites","text":"<p>Before creating a release, ensure you have:</p> <ul> <li> All changes merged to <code>main</code> branch</li> <li> All tests passing locally</li> <li> Git repository clean (no uncommitted changes)</li> <li> Access to push tags to GitHub</li> <li> PyPI account configured (for maintainers)</li> </ul>"},{"location":"how-to/HOW_TO_RELEASE/#release-types","title":"Release Types","text":"<p>Choose the appropriate version bump based on your changes:</p> <ul> <li>Patch (0.1.X): Bug fixes, documentation updates, minor improvements</li> <li>Minor (0.X.0): New features, backwards-compatible changes</li> <li>Major (X.0.0): Breaking changes, major architecture updates</li> </ul>"},{"location":"how-to/HOW_TO_RELEASE/#step-by-step-release-process","title":"Step-by-Step Release Process","text":""},{"location":"how-to/HOW_TO_RELEASE/#1-prepare-the-release","title":"1. Prepare the Release","text":""},{"location":"how-to/HOW_TO_RELEASE/#a-update-the-changelog","title":"a. Update the Changelog","text":"<p>Edit <code>CHANGELOG.md</code> to document all changes since the last release:</p> <pre><code># Open CHANGELOG.md in your editor\ncode CHANGELOG.md\n</code></pre> <p>Move items from <code>[Unreleased]</code> to a new version section:</p> <pre><code>## [Unreleased]\n\n&lt;!-- Leave empty for next release --&gt;\n\n## [0.2.0] - 2025-12-11\n\n### Added\n- New memory prioritization feature\n- Performance monitoring utilities\n\n### Changed\n- Improved caching performance\n\n### Fixed\n- Fixed SQLite backend connection leak\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#b-run-pre-release-checks","title":"b. Run Pre-Release Checks","text":"<pre><code># Run full test suite\nmake test\n# Or on Windows: pytest tests/ -v --cov=bruno_memory --cov-report=html --cov-report=term\n\n# Check code quality\nmake lint\n# Or on Windows: black --check bruno_memory/ tests/; ruff check bruno_memory/ tests/\n\n# Type checking\nmake type-check\n# Or on Windows: mypy bruno_memory/\n\n# Security audit\npip install pip-audit\npip-audit\n</code></pre> <p>Windows PowerShell users: If <code>make</code> is not available, use the expanded commands shown after \"Or on Windows\".</p> <p>All checks should pass before proceeding.</p>"},{"location":"how-to/HOW_TO_RELEASE/#2-bump-the-version","title":"2. Bump the Version","text":"<p>Use the automated version bumping script:</p> <pre><code># For patch release (0.1.0 -&gt; 0.1.1)\nmake bump-patch\n# Or on Windows: python scripts/bump_version.py patch\n\n# For minor release (0.1.0 -&gt; 0.2.0)\nmake bump-minor\n# Or on Windows: python scripts/bump_version.py minor\n\n# For major release (0.1.0 -&gt; 1.0.0)\nmake bump-major\n# Or on Windows: python scripts/bump_version.py major\n</code></pre> <p>Use the script directly with more options:</p> <pre><code># Dry run to see what will change\npython scripts/bump_version.py minor --dry-run\n\n# Bump version and create commit + tag\npython scripts/bump_version.py minor\n\n# Bump version without creating git commit\npython scripts/bump_version.py minor --no-commit\n\n# Bump version without creating git tag\npython scripts/bump_version.py minor --no-tag\n</code></pre> <p>What this does: - Updates version in <code>pyproject.toml</code> - Updates <code>__version__</code> in <code>bruno_memory/__init__.py</code> - Creates a git commit with message \"Bump version to X.Y.Z\" - Creates an annotated git tag <code>vX.Y.Z</code></p>"},{"location":"how-to/HOW_TO_RELEASE/#3-review-the-changes","title":"3. Review the Changes","text":"<pre><code># Check the version bump commit\ngit log -1\n\n# View the tag\ngit tag -l -n1 v*\n\n# Verify the version\npython -c \"import bruno_memory; print(bruno_memory.__version__)\"\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#4-push-to-github","title":"4. Push to GitHub","text":"<p>Push both the commit and the tag:</p> <pre><code># Push the commit\ngit push origin main\n\n# Push the tag (this triggers the release workflow)\ngit push origin v0.2.0\n</code></pre> <p>Important: Pushing the tag will automatically trigger: 1. GitHub Actions release workflow 2. Build of distribution packages 3. Creation of GitHub Release 4. Publishing to PyPI 5. Documentation deployment to GitHub Pages</p>"},{"location":"how-to/HOW_TO_RELEASE/#5-monitor-the-release","title":"5. Monitor the Release","text":""},{"location":"how-to/HOW_TO_RELEASE/#a-check-github-actions","title":"a. Check GitHub Actions","text":"<ol> <li>Go to Actions</li> <li>Find the \"Release\" workflow run</li> <li>Monitor progress of all jobs:</li> <li>Create GitHub Release</li> <li>Deploy Documentation</li> <li>Announce</li> </ol>"},{"location":"how-to/HOW_TO_RELEASE/#b-verify-the-github-release","title":"b. Verify the GitHub Release","text":"<ol> <li>Go to Releases</li> <li>Verify the new release is created</li> <li>Check that distribution files are attached (.tar.gz and .whl)</li> <li>Review the automatically generated changelog</li> </ol>"},{"location":"how-to/HOW_TO_RELEASE/#c-verify-pypi-publication","title":"c. Verify PyPI Publication","text":"<p>After the workflow completes (usually 5-10 minutes):</p> <pre><code># Check PyPI page\n# Visit: https://pypi.org/project/bruno-memory/\n\n# Test installation\npip install --upgrade bruno-memory==0.2.0\n\n# Verify version\npython -c \"import bruno_memory; print(bruno_memory.__version__)\"\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#d-verify-documentation","title":"d. Verify Documentation","text":"<p>Visit the documentation site: - URL: https://meggy-ai.github.io/bruno-memory/ - Verify the version in the footer - Test navigation and links - Check new features are documented</p>"},{"location":"how-to/HOW_TO_RELEASE/#6-post-release-tasks","title":"6. Post-Release Tasks","text":""},{"location":"how-to/HOW_TO_RELEASE/#a-update-the-github-release-notes","title":"a. Update the GitHub Release Notes","text":"<p>The release is created automatically, but you should enhance it:</p> <ol> <li>Go to the release page</li> <li>Click \"Edit release\"</li> <li>Add detailed release notes:</li> </ol> <pre><code>## \ud83c\udf89 What's New in v0.2.0\n\n### New Features\n- **Memory Prioritization**: Intelligent scoring system with 4 factors\n- **Performance Monitoring**: Track and optimize operations\n- **Security Enhancements**: Encryption and anonymization utilities\n\n### Improvements\n- Improved caching performance by 40%\n- Better error messages across all backends\n- Enhanced documentation with more examples\n\n### Bug Fixes\n- Fixed connection leak in SQLite backend\n- Resolved race condition in Redis cache\n- Corrected timestamp handling in PostgreSQL\n\n### Breaking Changes\nNone in this release.\n\n### Upgrade Instructions\n```bash\npip install --upgrade bruno-memory\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#documentation","title":"Documentation","text":"<p>Full documentation: https://meggy-ai.github.io/bruno-memory/</p>"},{"location":"how-to/HOW_TO_RELEASE/#contributors","title":"Contributors","text":"<p>Thank you to all contributors! \ud83d\ude4f <pre><code>#### b. Announce the Release\n\nShare the news with your community:\n\n**GitHub Discussions** (if enabled):\n1. Go to Discussions\n2. Create new post in \"Announcements\"\n3. Share release highlights and link\n\n**Social Media**:\n- Twitter/X: \"Released bruno-memory v0.2.0 with memory prioritization and performance monitoring! \ud83d\ude80\"\n- LinkedIn: Share with relevant groups\n- Reddit: r/Python, r/MachineLearning (if relevant)\n\n**Email** (if you have a mailing list):\n- Send release announcement to subscribers\n- Highlight breaking changes if any\n\n#### c. Close Related Issues\n\nGo through GitHub Issues and:\n1. Close issues that were fixed in this release\n2. Add comment: \"Fixed in v0.2.0\"\n3. Add the release milestone (if using milestones)\n\n#### d. Update Project Board\n\nIf using GitHub Projects:\n1. Move completed items to \"Done\"\n2. Close the release milestone\n3. Create milestone for next release\n\n### 7. Start Next Development Cycle\n\nPrepare for the next release:\n\n```bash\n# Update CHANGELOG.md\ncode CHANGELOG.md\n</code></pre></p> <p>Add a new <code>[Unreleased]</code> section at the top:</p> <pre><code>## [Unreleased]\n\n### Added\n\n### Changed\n\n### Deprecated\n\n### Removed\n\n### Fixed\n\n### Security\n\n## [0.2.0] - 2025-12-11\n...\n</code></pre> <p>Commit the change:</p> <pre><code>git add CHANGELOG.md\ngit commit -m \"Start v0.3.0 development cycle\"\ngit push origin main\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/HOW_TO_RELEASE/#the-workflow-failed","title":"The workflow failed","text":"<p>Check the logs: 1. Go to Actions tab 2. Click on the failed workflow 3. Review error messages Build fails: <pre><code># Test build locally\npip install build\npython -m build\npip install twine\ntwine check dist/*\n</code></pre></p> <p>Tests fail: <pre><code># Run tests locally (Linux/Mac)\nmake test\n\n# Run tests on Windows\npytest tests/ -v --cov=bruno_memory\n```bash\n# Run tests locally\nmake test\n</code></pre></p> <p>PyPI publishing fails: - Verify PyPI trusted publishing is configured - Check environment permissions in GitHub settings - Ensure version doesn't already exist on PyPI</p>"},{"location":"how-to/HOW_TO_RELEASE/#need-to-rollback-a-release","title":"Need to rollback a release","text":"<p>If you need to undo a release:</p> <pre><code># Delete the tag locally\ngit tag -d v0.2.0\n\n# Delete the tag remotely\ngit push origin :refs/tags/v0.2.0\n\n# Revert the version bump commit\ngit revert HEAD\ngit push origin main\n</code></pre> <p>On PyPI: - You cannot delete a release - Contact PyPI support to \"yank\" the release - Release a new patch version with fixes</p>"},{"location":"how-to/HOW_TO_RELEASE/#version-conflict-on-pypi","title":"Version conflict on PyPI","text":"<p>If the version already exists:</p> <pre><code># Delete the local tag\ngit tag -d v0.2.0\n\n# Bump to next version\npython scripts/bump_version.py patch\n\n# Push again\ngit push origin main\ngit push origin v0.2.1\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#hotfix-release-process","title":"Hotfix Release Process","text":"<p>For urgent bug fixes:</p>"},{"location":"how-to/HOW_TO_RELEASE/#1-create-hotfix-branch","title":"1. Create Hotfix Branch","text":"<pre><code># Create branch from the problematic release\ngit checkout -b hotfix/v0.2.1 v0.2.0\n\n# Make your fix\n# ... edit files ...\n\n# Commit the fix\ngit add .\ngit commit -m \"Fix critical bug in memory backend\"\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#2-bump-version","title":"2. Bump Version","text":"<pre><code># Bump patch version\npython scripts/bump_version.py patch\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#3-merge-and-release","title":"3. Merge and Release","text":"<pre><code># Switch to main\ngit checkout main\n\n# Merge hotfix\ngit merge hotfix/v0.2.1\n\n# Push\ngit push origin main\ngit push origin v0.2.1\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#4-fast-track-testing","title":"4. Fast-track Testing","text":"<p>For hotfixes, you may skip some checks but always: - [ ] Test the specific bug fix - [ ] Run relevant unit tests - [ ] Verify no new issues introduced</p>"},{"location":"how-to/HOW_TO_RELEASE/#release-checklist-summary","title":"Release Checklist Summary","text":"<p>Use this quick checklist for each release:</p> <pre><code>## Pre-Release\n- [ ] All tests passing\n- [ ] Changelog updated\n- [ ] Version bumped\n- [ ] Tag created and pushed\n\n## During Release\n- [ ] GitHub Actions workflow succeeds\n- [ ] GitHub Release created\n- [ ] PyPI package published\n- [ ] Documentation deployed\n\n## Post-Release\n- [ ] Verify installation from PyPI\n- [ ] Enhance release notes\n- [ ] Close related issues\n- [ ] Announce release\n- [ ] Start next development cycle\n</code></pre>"},{"location":"how-to/HOW_TO_RELEASE/#best-practices","title":"Best Practices","text":""},{"location":"how-to/HOW_TO_RELEASE/#dos","title":"Do's \u2705","text":"<ul> <li>Always update the changelog before releasing</li> <li>Test thoroughly before pushing tags</li> <li>Use semantic versioning consistently</li> <li>Write detailed release notes</li> <li>Announce breaking changes prominently</li> <li>Keep a regular release schedule</li> </ul>"},{"location":"how-to/HOW_TO_RELEASE/#donts","title":"Don'ts \u274c","text":"<ul> <li>Don't push tags without testing</li> <li>Don't skip changelog updates</li> </ul>"},{"location":"how-to/HOW_TO_RELEASE/#automation-tips","title":"Automation Tips","text":""},{"location":"how-to/HOW_TO_RELEASE/#create-release-script","title":"Create Release Script","text":"<p>For Linux/Mac - Save this as <code>scripts/release.sh</code>:</p> <pre><code>#!/bin/bash\nset -e\n\nVERSION=$1\nTYPE=${2:-minor}\n\necho \"\ud83d\ude80 Creating release $VERSION\"\n\n# Pre-checks\necho \"\ud83d\udccb Running pre-release checks...\"\nmake test\nmake lint\n\n# Update changelog\necho \"\ud83d\udcdd Update CHANGELOG.md and press Enter\"\nread\n\n# Bump version\necho \"\u2b06\ufe0f  Bumping version...\"\npython scripts/bump_version.py $TYPE\n\n# Push\necho \"\ud83d\udd3c Pushing to GitHub...\"\ngit push origin main\ngit push origin v$VERSION\n\necho \"\u2705 Release v$VERSION initiated!\"\necho \"Monitor: https://github.com/meggy-ai/bruno-memory/actions\"\n</code></pre> <p>Use it: <pre><code>chmod +x scripts/release.sh\n./scripts/release.sh 0.2.0 minor\n</code></pre></p> <p>For Windows PowerShell - Save this as <code>scripts/release.ps1</code>:</p> <pre><code>param(\n    [Parameter(Mandatory=$true)]\n    [string]$Version,\n    [string]$Type = \"minor\"\n)\n\nWrite-Host \"\ud83d\ude80 Creating release $Version\" -ForegroundColor Green\n\n# Pre-checks\nWrite-Host \"\ud83d\udccb Running pre-release checks...\" -ForegroundColor Yellow\npytest tests/ -v --cov=bruno_memory\nif ($LASTEXITCODE -ne 0) { exit 1 }\n\nblack --check bruno_memory/ tests/\nif ($LASTEXITCODE -ne 0) { exit 1 }\n\nruff check bruno_memory/ tests/\nif ($LASTEXITCODE -ne 0) { exit 1 }\n\n# Update changelog\nWrite-Host \"\ud83d\udcdd Update CHANGELOG.md and press Enter\" -ForegroundColor Yellow\nRead-Host\n\n# Bump version\nWrite-Host \"\u2b06\ufe0f  Bumping version...\" -ForegroundColor Yellow\npython scripts/bump_version.py $Type\nif ($LASTEXITCODE -ne 0) { exit 1 }\n\n# Push\nWrite-Host \"\ud83d\udd3c Pushing to GitHub...\" -ForegroundColor Yellow\ngit push origin main\ngit push origin \"v$Version\"\n\nWrite-Host \"\u2705 Release v$Version initiated!\" -ForegroundColor Green\nWrite-Host \"Monitor: https://github.com/meggy-ai/bruno-memory/actions\"\n</code></pre> <p>Use it: <pre><code>.\\scripts\\release.ps1 -Version \"0.2.0\" -Type \"minor\"\n</code></pre> Use it: <pre><code>chmod +x scripts/release.sh\n./scripts/release.sh 0.2.0 minor\n</code></pre></p>"},{"location":"how-to/HOW_TO_RELEASE/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check documentation: Review this guide and <code>CI_CD_GUIDE.md</code></li> <li>GitHub Actions logs: Review workflow runs for errors</li> <li>Ask for help: Create an issue or discussion</li> <li>Contact maintainers: Reach out via email or Slack</li> </ol>"},{"location":"how-to/HOW_TO_RELEASE/#additional-resources","title":"Additional Resources","text":"<ul> <li>Semantic Versioning</li> <li>Keep a Changelog</li> <li>GitHub Actions Documentation</li> <li>PyPI Trusted Publishing</li> <li>Python Packaging Guide</li> </ul> <p>Ready to release? Follow this guide step by step and you'll have a smooth release process! \ud83c\udf89</p>"}]}